<?xml version="1.0"?><CLASS_ROOT><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>ECTR - Normalizzatore</DESCRIPT><UUID>AFBWoCPaHuiU0qXf1F6fkA==</UUID><CATEGORY>00</CATEGORY><EXPOSURE>2</EXPOSURE><STATE>1</STATE><RELEASE>0</RELEASE><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><CHGDANYON>0000-00-00</CHGDANYON><CLSCCINCL>X</CLSCCINCL><FIXPT>X</FIXPT><UNICODE>X</UNICODE><R3RELEASE>750</R3RELEASE><CLSBCCAT>00</CLSBCCAT><DURATION_TYPE>0</DURATION_TYPE><RISK_LEVEL>0</RISK_LEVEL><ATTRIBUTES><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GS_SEL</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><ATTDECLTYP>0</ATTDECLTYP><ATTEXPVIRT>0</ATTEXPVIRT><TYPTYPE>1</TYPTYPE><TYPE>TY_S_SEL</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GT_DATA</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>2</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><ATTDECLTYP>0</ATTDECLTYP><ATTEXPVIRT>0</ATTEXPVIRT><TYPTYPE>1</TYPTYPE><TYPE>TY_T_DATA</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GT_PDM_NOR_BOM</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>3</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><ATTDECLTYP>0</ATTDECLTYP><ATTEXPVIRT>0</ATTEXPVIRT><TYPTYPE>1</TYPTYPE><TYPE>TY_T_NOR_BOM</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GT_PDM_MON_BOM</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>4</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><ATTDECLTYP>0</ATTDECLTYP><ATTEXPVIRT>0</ATTEXPVIRT><TYPTYPE>1</TYPTYPE><TYPE>TY_T_PDM_MON_BOM</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GT_PDM_MON_ANAG</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>5</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><ATTDECLTYP>0</ATTDECLTYP><ATTEXPVIRT>0</ATTEXPVIRT><TYPTYPE>1</TYPTYPE><TYPE>TY_T_PDM_MON_ANAG</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GV_FASE</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Fase corrente</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>6</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><ATTDECLTYP>0</ATTDECLTYP><ATTEXPVIRT>0</ATTEXPVIRT><TYPTYPE>1</TYPTYPE><TYPE>NUMC1</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GT_ROOTNAMES</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>7</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-17</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><ATTDECLTYP>0</ATTDECLTYP><ATTEXPVIRT>0</ATTEXPVIRT><TYPTYPE>1</TYPTYPE><TYPE>TY_T_ROOTNAMES</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item></ATTRIBUTES><METHODS><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CONSTRUCTOR</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Costruttore</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><MTDTYPE>2</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><MTDNEWEXC>X</MTDNEWEXC><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>INITIALIZATION</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Inizializzazione</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>2</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><MTDNEWEXC>X</MTDNEWEXC><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>RUN</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Esegue il programma</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>3</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><MTDNEWEXC>X</MTDNEWEXC><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_SEL</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Ritorna i parametri di selezione</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>4</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CREATE_TREE_OLD</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Crea inserimenti albero</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>5</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CREATE_PDM_NOR_BOM</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Crea inserimenti tabella ZPP_PDM_NOR_BOM</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>6</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-09</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><MTDNEWEXC>X</MTDNEWEXC><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_CURRENT_FASE</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>7</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-09</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>SEND_TO_TREE</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>8</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-10</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><MTDNEWEXC>X</MTDNEWEXC><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>AUTORITY_CHECK</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Non usato</DESCRIPT><EXPOSURE>1</EXPOSURE><STATE>1</STATE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><MTDNEWEXC>X</MTDNEWEXC><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CREATE_SELECTIONS</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Crea selezioni</DESCRIPT><EXPOSURE>1</EXPOSURE><STATE>1</STATE><EDITORDER>2</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><MTDNEWEXC>X</MTDNEWEXC><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>SET_TABLES_FASE_1</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Crea dati tabella per update</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><MTDNEWEXC>X</MTDNEWEXC><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>UPDATE_TABLES_FASE_1</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Update delle tabelle</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>2</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>FIND_ROOTNAME</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Creca il rootname e info aggiuntive</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>3</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-08</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>FIND_ROOTNAME_2</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Creca il rootname e info aggiuntive</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>4</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-10</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>SET_TABLES_FASE_2</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Crea dati tabella per update</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>5</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>UPDATE_TABLES_FASE_2</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Update delle tabelle</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>6</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>DELETE_USELESS_NODES</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Applica gli algoritimi: in laterale e in profondità</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>7</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-28</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>FIND_ROOTNAME_SCH</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Creca il rootname e info aggiuntive - scheletro</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>8</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-10</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-28</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>FIND_ROOTNAME_ELE</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Creca il rootname e info aggiuntive - elettrico</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>9</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-10</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-28</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>FIND_ROOTNAME_MEC</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Creca il rootname e info aggiuntive - meccanico</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>10</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-10</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-28</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>DELETE_DUPLICATES</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Elimina duplicati dalla tabella GT_DATA</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>11</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-17</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-28</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_ACTIVE_COMPONENTS</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Estrazione componenti attivi per i rootname trovati</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>12</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-28</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_WBS_DISPO</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Aggiunge valori</DESCRIPT><EXPOSURE>0</EXPOSURE><STATE>1</STATE><EDITORDER>13</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-28</CHANGEDON><MTDTYPE>0</MTDTYPE><MTDDECLTYP>0</MTDDECLTYP><R3RELEASE>750</R3RELEASE><BCMTDCAT>00</BCMTDCAT><BCMTDSYN>0</BCMTDSYN></item></METHODS><EVENTS/><TYPES><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_S_ROOTNAME</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>8</SRCROW1><SRCCOLUMN1>11</SRCCOLUMN1><SRCROW2>11</SRCROW2><SRCCOLUMN2>30</SRCCOLUMN2><TYPESRC_LENG>129</TYPESRC_LENG><TYPESRC>BEGIN OF ty_s_rootname.
        INCLUDE TYPE zsppp_ectr_norm.
    TYPES:   aennr TYPE aennr.
    TYPES: END OF ty_s_rootname
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_T_ROOTNAME</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>2</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>12</SRCROW1><SRCCOLUMN1>11</SRCCOLUMN1><SRCROW2>12</SRCROW2><SRCCOLUMN2>51</SRCCOLUMN2><TYPESRC_LENG>43</TYPESRC_LENG><TYPESRC>ty_t_rootname TYPE TABLE OF ty_s_rootname
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_S_ROOTNAMES</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>3</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-17</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>13</SRCROW1><SRCCOLUMN1>11</SRCCOLUMN1><SRCROW2>15</SRCROW2><SRCCOLUMN2>31</SRCCOLUMN2><TYPESRC_LENG>106</TYPESRC_LENG><TYPESRC>BEGIN OF ty_s_rootnames,
             rootname TYPE zpp_pdm_rootname,
           END OF ty_s_rootnames
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_T_ROOTNAMES</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>4</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-17</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>16</SRCROW1><SRCCOLUMN1>11</SRCCOLUMN1><SRCROW2>16</SRCROW2><SRCCOLUMN2>53</SRCCOLUMN2><TYPESRC_LENG>45</TYPESRC_LENG><TYPESRC>ty_t_rootnames TYPE TABLE OF ty_s_rootnames
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_S_PDM_MON_BOM</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Cruscotto produzione: distinte base</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>5</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><TYPTYPE>1</TYPTYPE><TYPE>ZPP_PDM_MON_BOM</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_T_PDM_MON_BOM</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>6</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>20</SRCROW1><SRCCOLUMN1>6</SRCCOLUMN1><SRCROW2>20</SRCROW2><SRCCOLUMN2>52</SRCCOLUMN2><TYPESRC_LENG>49</TYPESRC_LENG><TYPESRC>ty_t_pdm_mon_bom TYPE TABLE OF ty_s_pdm_mon_bom
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_S_PDM_MON_ANAG</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Cruscotto produzione: anagrafica</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>7</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><TYPTYPE>1</TYPTYPE><TYPE>ZPP_PDM_MON_ANAG</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_T_PDM_MON_ANAG</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>8</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>23</SRCROW1><SRCCOLUMN1>6</SRCCOLUMN1><SRCROW2>23</SRCROW2><SRCCOLUMN2>54</SRCCOLUMN2><TYPESRC_LENG>51</TYPESRC_LENG><TYPESRC>ty_t_pdm_mon_anag TYPE TABLE OF ty_s_pdm_mon_anag
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_S_DATA</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>9</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>25</SRCROW1><SRCCOLUMN1>6</SRCCOLUMN1><SRCROW2>29</SRCROW2><SRCCOLUMN2>26</SRCCOLUMN2><TYPESRC_LENG>157</TYPESRC_LENG><TYPESRC>BEGIN OF ty_s_data.
        INCLUDE TYPE zsppp_ectr_norm.
        INCLUDE TYPE zpp_modbom.
    TYPES: log TYPE zpp_bom_log.
    TYPES: END OF ty_s_data
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_S_PDM_NOR_BOM</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Normalizza.: BOM trasferite al Cruscotto Prod. (ultima foto)</DESCRIPT><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>10</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><TYPTYPE>1</TYPTYPE><TYPE>ZPP_PDM_NOR_BOM</TYPE><SRCROW1>0</SRCROW1><SRCCOLUMN1>0</SRCCOLUMN1><SRCROW2>0</SRCROW2><SRCCOLUMN2>0</SRCCOLUMN2><TYPESRC_LENG>0</TYPESRC_LENG></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_T_DATA</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>11</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>32</SRCROW1><SRCCOLUMN1>6</SRCCOLUMN1><SRCROW2>32</SRCROW2><SRCCOLUMN2>38</SRCCOLUMN2><TYPESRC_LENG>35</TYPESRC_LENG><TYPESRC>ty_t_data TYPE TABLE OF ty_s_data
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_T_NOR_BOM</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>12</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>34</SRCROW1><SRCCOLUMN1>6</SRCCOLUMN1><SRCROW2>34</SRCROW2><SRCCOLUMN2>48</SRCCOLUMN2><TYPESRC_LENG>45</TYPESRC_LENG><TYPESRC>ty_t_nor_bom TYPE TABLE OF ty_s_pdm_nor_bom
</TYPESRC></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>TY_S_SEL</CMPNAME><VERSION>1</VERSION><LANGU>I</LANGU><EXPOSURE>2</EXPOSURE><STATE>1</STATE><EDITORDER>13</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-25</CHANGEDON><TYPTYPE>4</TYPTYPE><SRCROW1>36</SRCROW1><SRCCOLUMN1>6</SRCCOLUMN1><SRCROW2>44</SRCROW2><SRCCOLUMN2>20</SRCCOLUMN2><TYPESRC_LENG>351</TYPESRC_LENG><TYPESRC>BEGIN OF ty_s_sel,
        s_dispo   TYPE RANGE OF marc-dispo,
        s_root    TYPE RANGE OF zpp_albero-rootname,
        s_matnr   TYPE RANGE OF mara-matnr,
        s_posid   TYPE RANGE OF prps-posid,
        p_layo1 TYPE disvariant-variant,
        p_layo2 TYPE disvariant-variant,
        p_test    TYPE abap_bool,
      END OF ty_s_sel
</TYPESRC></item></TYPES><PARAMETERS><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CONSTRUCTOR</CMPNAME><SCONAME>IV_PROGRAM</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Programma chiamante</DESCRIPT><CMPTYPE>1</CMPTYPE><MTDTYPE>2</MTDTYPE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>SY-REPID</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CONSTRUCTOR</CMPNAME><SCONAME>IV_LANGUAGE</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Campo sistema ABAP: chiave lingua dell&apos;ambiente testi</DESCRIPT><CMPTYPE>1</CMPTYPE><MTDTYPE>2</MTDTYPE><EDITORDER>2</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>SY-LANGU</TYPE><PARVALUE>SY-LANGU</PARVALUE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CONSTRUCTOR</CMPNAME><SCONAME>IS_SEL</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Parametri di selezione</DESCRIPT><CMPTYPE>1</CMPTYPE><MTDTYPE>2</MTDTYPE><EDITORDER>3</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>TY_S_SEL</TYPE><PAROPTIONL>X</PAROPTIONL></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CONSTRUCTOR</CMPNAME><SCONAME>IV_PFSTATUS</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Stato GUI</DESCRIPT><CMPTYPE>1</CMPTYPE><MTDTYPE>2</MTDTYPE><EDITORDER>4</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>SYPFKEY</TYPE><PAROPTIONL>X</PAROPTIONL></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CREATE_PDM_NOR_BOM</CMPNAME><SCONAME>IV_SHOW_ALV</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>ABAP_BOOL</TYPE><PARVALUE>ABAP_FALSE</PARVALUE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CREATE_TREE_OLD</CMPNAME><SCONAME>IV_SHOW_ALV</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>ABAP_BOOL</TYPE><PARVALUE>ABAP_FALSE</PARVALUE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_ACTIVE_COMPONENTS</CMPNAME><SCONAME>IV_PREFIX</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>STRING</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_ACTIVE_COMPONENTS</CMPNAME><SCONAME>CT_ROOTNAME</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>2</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><PARDECLTYP>2</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>TY_T_ROOTNAME</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_ACTIVE_COMPONENTS</CMPNAME><SCONAME>RT_PDM_NOR_BOM</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Tipo tabella per ZPP_PDM_NOR_BOM</DESCRIPT><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>3</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDBY>KOSMEDEV</CHANGEDBY><CHANGEDON>2018-05-22</CHANGEDON><PARDECLTYP>3</PARDECLTYP><PARPASSTYP>0</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>ZPP_PDM_NOR_BOM_T</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_CURRENT_FASE</CMPNAME><SCONAME>RV_RET</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>3</PARDECLTYP><PARPASSTYP>0</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>ABAP_BOOL</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_SEL</CMPNAME><SCONAME>ES_SEL</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>3</PARDECLTYP><PARPASSTYP>0</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>TY_S_SEL</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_WBS_DISPO</CMPNAME><SCONAME>IV_ROOTNAME</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Rootname</DESCRIPT><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>ZPP_ALBERO-ROOTNAME</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_WBS_DISPO</CMPNAME><SCONAME>CV_POSID</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Elemento della Work Breakdown Structure (elemento WBS)</DESCRIPT><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>2</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>2</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>PRPS-POSID</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>GET_WBS_DISPO</CMPNAME><SCONAME>CV_DISPO</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Resp. MRP</DESCRIPT><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>3</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-22</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>2</PARDECLTYP><PARPASSTYP>1</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>MARC-DISPO</TYPE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>RUN</CMPNAME><SCONAME>IV_SHOW_ALV</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><CMPTYPE>1</CMPTYPE><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><DISPID>0</DISPID><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><PARDECLTYP>0</PARDECLTYP><PARPASSTYP>0</PARPASSTYP><TYPTYPE>1</TYPTYPE><TYPE>ABAP_BOOL</TYPE><PARVALUE>ABAP_TRUE</PARVALUE></item></PARAMETERS><EXCEPTIONS><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>AUTORITY_CHECK</CMPNAME><SCONAME>ZCX_BC_EXCEPTION</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Classe eccezione autorizzazione</DESCRIPT><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><IS_RESUMABLE>X</IS_RESUMABLE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CONSTRUCTOR</CMPNAME><SCONAME>ZCX_BC_EXCEPTION</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Classe eccezione autorizzazione</DESCRIPT><MTDTYPE>2</MTDTYPE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><IS_RESUMABLE>X</IS_RESUMABLE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CREATE_PDM_NOR_BOM</CMPNAME><SCONAME>ZCX_BC_EXCEPTION</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Classe eccezione autorizzazione</DESCRIPT><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><IS_RESUMABLE>X</IS_RESUMABLE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>CREATE_SELECTIONS</CMPNAME><SCONAME>ZCX_BC_EXCEPTION</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Classe eccezione autorizzazione</DESCRIPT><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><IS_RESUMABLE>X</IS_RESUMABLE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>INITIALIZATION</CMPNAME><SCONAME>ZCX_BC_EXCEPTION</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Classe eccezione autorizzazione</DESCRIPT><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><IS_RESUMABLE>X</IS_RESUMABLE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>RUN</CMPNAME><SCONAME>ZCX_BC_EXCEPTION</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Classe eccezione autorizzazione</DESCRIPT><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><IS_RESUMABLE>X</IS_RESUMABLE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>SEND_TO_TREE</CMPNAME><SCONAME>ZCX_BC_EXCEPTION</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Classe eccezione autorizzazione</DESCRIPT><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-10</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><IS_RESUMABLE>X</IS_RESUMABLE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><CMPNAME>SET_TABLES_FASE_1</CMPNAME><SCONAME>ZCX_BC_EXCEPTION</SCONAME><VERSION>1</VERSION><LANGU>I</LANGU><DESCRIPT>Classe eccezione autorizzazione</DESCRIPT><MTDTYPE>0</MTDTYPE><EDITORDER>1</EDITORDER><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-09</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON><IS_RESUMABLE>X</IS_RESUMABLE></item></EXCEPTIONS><IMPLEMENTINGS/><IMPL_DETAILS/><FRIENDSHIPS/><TYPEPUSAGES><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><TYPEGROUP>ABAP</TYPEGROUP><VERSION>1</VERSION><TPUTYPE>0</TPUTYPE><IMPLICIT>X</IMPLICIT></item></TYPEPUSAGES><CLSDEFERRDS/><INTDEFERRDS/><ALIASES/><INHERITANCE><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><REFCLSNAME>ZCL_BC_PROGRAM_BASE_2</REFCLSNAME><VERSION>1</VERSION><STATE>1</STATE><AUTHOR>KOSMEDEV</AUTHOR><CREATEDON>2018-05-08</CREATEDON><CHANGEDON>0000-00-00</CHANGEDON></INHERITANCE><INTERFACES/><REDEFINITIONS><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><REFCLSNAME>ZCL_BC_PROGRAM_BASE_2</REFCLSNAME><VERSION>1</VERSION><MTDNAME>ALV_SHOW</MTDNAME><EXPOSURE>2</EXPOSURE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><REFCLSNAME>ZCL_BC_PROGRAM_BASE_2</REFCLSNAME><VERSION>1</VERSION><MTDNAME>MODIFY_SCREEN</MTDNAME><EXPOSURE>2</EXPOSURE></item><item><CLSNAME>ZCL_PP_ECTR_NORM</CLSNAME><REFCLSNAME>ZCL_BC_PROGRAM_BASE_2</REFCLSNAME><VERSION>1</VERSION><MTDNAME>SET_DATA</MTDNAME><EXPOSURE>2</EXPOSURE></item></REDEFINITIONS><TYPE_SOURCE/><LOCALS_SRC/><LOCALS_DEF><item>*&quot;* use this source file for any type of declarations (class</item><item>*&quot;* definitions, interfaces or type declarations) you need for</item><item>*&quot;* components in the private section</item><item/></LOCALS_DEF><LOCALS_IMP><item>*&quot;* use this source file for the definition and implementation of</item><item>*&quot;* local helper classes, interface definitions and type</item><item>*&quot;* declarations</item><item/><item>CLASS lcl_handle_events DEFINITION.</item><item>  PUBLIC SECTION.</item><item>    METHODS:</item><item>      constructor IMPORTING io_sender TYPE REF TO zcl_pp_ectr_norm</item><item>                            io_alv    TYPE REF TO cl_salv_table</item><item>                            io_sel    TYPE REF TO cl_salv_selections,</item><item>      on_user_command FOR EVENT added_function OF cl_salv_events</item><item>        IMPORTING e_salv_function.</item><item>  PRIVATE SECTION.</item><item>    DATA: go_sender TYPE REF TO zcl_pp_ectr_norm,</item><item>          go_alv    TYPE REF TO cl_salv_table,</item><item>          go_sel    TYPE REF TO cl_salv_selections.</item><item>*    METHODS:</item><item>*      edit.</item><item>ENDCLASS.</item><item/><item>CLASS lcl_handle_events IMPLEMENTATION.</item><item>  METHOD constructor.</item><item>    go_sender = io_sender.</item><item>    go_alv = io_alv.</item><item>    go_sel = io_sel.</item><item>  ENDMETHOD.</item><item>  METHOD on_user_command.</item><item>    DATA: lo_selections TYPE REF TO cl_salv_selections,</item><item>          lo_salv       TYPE REF TO cl_salv_table.</item><item>    DATA: lt_rows TYPE salv_t_row.</item><item>    DATA: ls_rows TYPE i.</item><item>    DATA: message TYPE string.</item><item>    CASE e_salv_function.</item><item>      WHEN &apos;EXECUTE&apos;.</item><item>        TRY.</item><item>            go_sender-&gt;create_pdm_nor_bom( iv_show_alv = abap_true ).</item><item>            go_sender-&gt;set_refresh_data( abap_true ).</item><item>          CATCH cx_root INTO DATA(lcx_root).</item><item>            MESSAGE lcx_root-&gt;get_text( ) TYPE &apos;S&apos;.</item><item>        ENDTRY.</item><item>      WHEN &apos;EXECUTE2&apos;.</item><item>        TRY.</item><item>            go_sender-&gt;send_to_tree( ).</item><item>            go_sender-&gt;set_refresh_data( abap_true ).</item><item>          CATCH cx_root INTO lcx_root.</item><item>            MESSAGE lcx_root-&gt;get_text( ) TYPE &apos;S&apos;.</item><item>        ENDTRY.</item><item>*      WHEN &apos;REFRESH&apos;.</item><item>*        go_sender-&gt;set_refresh_data( abap_true ).</item><item>*        go_sender-&gt;refresh_data( ).</item><item>*        go_alv-&gt;refresh( refresh_mode = if_salv_c_refresh=&gt;full ).</item><item>*      WHEN &apos;&amp;&amp;BACK&apos;.</item><item>*        LEAVE TO SCREEN 0.</item><item>    ENDCASE.</item><item>    TRY.</item><item>        IF ( go_sender-&gt;get_refresh_data( ) = abap_true ).</item><item>          go_sender-&gt;refresh_data( ).</item><item>        ENDIF.</item><item>        go_alv-&gt;refresh( refresh_mode = if_salv_c_refresh=&gt;full ).</item><item>      CATCH cx_root.</item><item>    ENDTRY.</item><item>  ENDMETHOD.</item><item>ENDCLASS.</item></LOCALS_IMP><LOCALS_MAC><item>*&quot;* use this source file for any macro definitions you need</item><item>*&quot;* in the implementation part of the class</item><item/></LOCALS_MAC><TEXT_POOL><I><item><ID>I</ID><KEY>001</KEY><ENTRY>BOM</ENTRY><LENGTH>54</LENGTH></item><item><ID>I</ID><KEY>002</KEY><ENTRY>TREE</ENTRY><LENGTH>70</LENGTH></item><item><ID>I</ID><KEY>003</KEY><ENTRY>Nessun dato estratto</ENTRY><LENGTH>40</LENGTH></item></I></TEXT_POOL><METHOD_SOURCE><AUTORITY_CHECK><item>  METHOD autority_check.</item><item>*    AUTHORITY-CHECK OBJECT &apos;M_BEST_WRK&apos;</item><item>*       ID &apos;ACTVT&apos; DUMMY</item><item>*       ID &apos;WERKS&apos; FIELD gs_sel-p_werks.</item><item>*    IF sy-subrc &lt;&gt; 0.</item><item>*      RAISE EXCEPTION TYPE zcx_bc_exception MESSAGE s001(zmmm_modula) WITH gs_sel-p_werks.</item><item>*    ENDIF.</item><item>  ENDMETHOD.</item></AUTORITY_CHECK><CONSTRUCTOR><item>  METHOD constructor.</item><item>    super-&gt;constructor( iv_program = iv_program iv_language = iv_language iv_pfstatus = iv_pfstatus ).</item><item>    create_selections( ).</item><item>    gv_fase = 0.</item><item>  ENDMETHOD.</item></CONSTRUCTOR><CREATE_SELECTIONS><item>  METHOD create_selections.</item><item>    DATA: lref_sel TYPE REF TO data.</item><item>    CREATE DATA lref_sel TYPE ty_s_sel.</item><item>    set_selections( CHANGING cref_sel = lref_sel ).</item><item>    FIELD-SYMBOLS: &lt;sel&gt;    TYPE any.</item><item>    ASSIGN lref_sel-&gt;* TO &lt;sel&gt;.</item><item>    IF ( sy-subrc = 0 ).</item><item>      gs_sel = &lt;sel&gt;.</item><item>    ENDIF.</item><item>  ENDMETHOD.</item></CREATE_SELECTIONS><GET_SEL><item>  METHOD get_sel.</item><item>    es_sel = gs_sel.</item><item>  ENDMETHOD.</item></GET_SEL><INITIALIZATION><item>  METHOD initialization.</item><item>  ENDMETHOD.</item></INITIALIZATION><RUN><item>  METHOD run.</item><item/><item>    create_selections( ).</item><item>    initialization( ).</item><item>    autority_check( ).</item><item/><item>*   Estrazione dati nella tabella interna gt_data dalla tabella ZPP_MODBOM</item><item>*   Elaborazione dei record estratti in gt_data per aggiungere i ROOTNAME ed eventuali</item><item>*   altri legami di BOM per avere la reale esplosione :</item><item>*   - sia in laterale cioè coinvolgendo tutte le WBS interessate, ad es. se abbiamo un nuovo legame</item><item>*     Padre - Componente su una BOM già esistente (il Padre aveva già altri Componenti) ed utilizzata</item><item>*     da più WBS allora tale nuovo legame deve essere (se non lo abbiamo già in gt_data) propagato a tutte</item><item>*     le WBS</item><item>*   - sia verso in basso, se un nodo foglia in gt_data ha BOM la sua BOM va recuperata</item><item>    set_data( ).   &quot;&lt;------</item><item/><item>    alv_create( EXPORTING iv_title = &apos;BOM&apos;(001)</item><item>                          iv_layout = gs_sel-p_layo1</item><item>                CHANGING ct_data = gt_data ).</item><item>    IF ( iv_show_alv = abap_true ).</item><item>      me-&gt;alv_show( ).</item><item>    ENDIF.</item><item/><item>    IF ( sy-batch = abap_true ).</item><item>*     Siamo in esecuzione Batch</item><item>*     Step 1 - Valorizzazione della tabella ZPP_PDM_NOR_BOM</item><item>      create_pdm_nor_bom( iv_show_alv = iv_show_alv ).</item><item>*     Step 2 - Valorizzazione delle tabelle ZPP_PDM_MON_ANAG e ZPP_PDM_MON_BOM</item><item>      send_to_tree( ).</item><item>    ENDIF.</item><item/><item>  ENDMETHOD.</item></RUN><ALV_SHOW><item>  METHOD alv_show.</item><item>    DATA : lo_selections    TYPE REF TO cl_salv_selections,</item><item>           lo_events        TYPE REF TO cl_salv_events_table,</item><item>           lo_event_handler TYPE REF TO lcl_handle_events,</item><item>           lo_sel           TYPE REF TO cl_salv_selections.</item><item/><item>    lo_sel = go_alv-&gt;get_selections( ).</item><item>    lo_sel-&gt;set_selection_mode( if_salv_c_selection_mode=&gt;multiple ).</item><item/><item>    lo_events = go_alv-&gt;get_event( ).</item><item>    lo_event_handler = NEW lcl_handle_events( io_sender = me</item><item>                                              io_alv    = go_alv</item><item>                                              io_sel    = lo_sel ).</item><item/><item>    SET HANDLER lo_event_handler-&gt;on_user_command FOR lo_events.</item><item/><item>    super-&gt;alv_show( ).</item><item>  ENDMETHOD.</item></ALV_SHOW><MODIFY_SCREEN><item>  METHOD modify_screen.</item><item>    super-&gt;modify_screen( ).</item><item>    create_selections( ).</item><item/><item>  ENDMETHOD.</item></MODIFY_SCREEN><SET_DATA><item>METHOD set_data.</item><item>  REFRESH: gt_data, gt_pdm_nor_bom, gt_pdm_mon_bom, gt_pdm_mon_anag.</item><item/><item>*   Estrazione dello stato di rilascio del change number 5* (CAD Meccanico)</item><item>  TRY.</item><item>      DATA: lv_prefix TYPE string.</item><item>      &quot; ritorna lo stato del change number in cui è possibile il trasferimento del file</item><item>      &quot; il parametro di importing ev_prefix rappresenta il numero iniziale del change number</item><item>      DATA(lv_aenst) = zcl_pp_ectr=&gt;get_cad_mec_bom_status( IMPORTING ev_prefix = lv_prefix ).</item><item>      lv_prefix = lv_prefix &amp;&amp; &apos;%&apos;.</item><item>    CATCH cx_root.</item><item>  ENDTRY.</item><item/><item>*   Estrazione dalla tabella ZPP_MODBOM delle 3 possibili casistiche</item><item>  SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_data</item><item>           FROM zpp_modbom</item><item>*                      Gestione BOM SCHELETRO</item><item>           WHERE ( ( aennr = space AND sortf_new = zcl_pp_ectr=&gt;c_scheletro ) OR   &quot;SCHELETRO</item><item>*                      Gestione CAD Meccanico</item><item>                   ( aennr LIKE lv_prefix AND EXISTS ( SELECT * FROM aenr WHERE aennr = zpp_modbom~aennr</item><item>                                                                          AND   aenst = lv_aenst ) ) OR</item><item>*                      Gestione CAD Elettrico</item><item>                   ( aennr LIKE &apos;BOM-%&apos; AND ( sortf_old LIKE &apos;E%&apos; OR sortf_new LIKE &apos;E%&apos; ) ) )</item><item>           AND   matnr  IN gs_sel-s_matnr</item><item>           AND   zflag1 = abap_true</item><item>           AND   zflag2 = abap_false</item><item>           ORDER BY datum uzeit matnr idnrk vbkz.</item><item/><item>  LOOP AT gt_data INTO DATA(ls_data) WHERE matnr(1) &lt;&gt; &apos;K&apos;</item><item>                                       AND matnr(1) = &apos;6&apos;.</item><item>    DATA(lv_tabix) = sy-tabix.</item><item>    SELECT SINGLE matnr INTO @DATA(lv_matnr)</item><item>           FROM marc</item><item>           WHERE werks = @zcl_pp_ectr=&gt;c_werks  &quot;6301</item><item>           AND   matnr = @ls_data-matnr</item><item>           AND   disgr = @zcl_pp_ectr=&gt;c_disgr  &quot;ZMTO</item><item>           AND ( beskz = &apos;E&apos; OR ( beskz = &apos;F&apos; AND sobsl = &apos;30&apos; ) ).</item><item>    IF ( sy-subrc &lt;&gt; 0 ).</item><item>*       Fuori ambito</item><item>      IF ( gs_sel-p_test = abap_false ).</item><item>        UPDATE zpp_modbom SET zflag2 = &apos;I&apos; WHERE aennr        = ls_data-aennr</item><item>                                           AND   stlan        = ls_data-stlan</item><item>                                           AND   datum        = ls_data-datum</item><item>                                           AND   uzeit        = ls_data-uzeit</item><item>                                           AND   matnr        = ls_data-matnr</item><item>                                           AND   posnr        = ls_data-posnr</item><item>                                           AND   pspnr        = ls_data-pspnr</item><item>                                           AND   idnrk        = ls_data-idnrk</item><item>                                           AND   werks        = ls_data-werks</item><item>                                           AND   stlal        = ls_data-stlal</item><item>                                           AND   vbkz         = ls_data-vbkz</item><item>                                           AND   oitxt        = ls_data-oitxt</item><item>                                           AND   relstartdate = ls_data-relstartdate</item><item>                                           AND   relenddate   = ls_data-relenddate.</item><item>      ENDIF.</item><item>      DELETE gt_data INDEX lv_tabix.</item><item>    ENDIF.</item><item>  ENDLOOP.</item><item/><item>*   Da tener presente che in gt_data i legami di BOM SCHELETRO già elaborati in precedenti BOM SCHELETRO</item><item>*   non sono presenti perchè bloccate a monte dal programma ZPP_PDM_TO_SAP</item><item>*   Tali legami saranno aggiunti dall&apos;algoritmo di propagazione verso il basso</item><item/><item>*   Per ogni record in gt_data determina il relativo ROOTNAME</item><item>*   find_rootname( ).</item><item>  find_rootname_2( ).   &quot;&lt;------</item><item/><item>  delete_useless_nodes( ).</item><item/><item>  &quot; non cancellare nè spostare</item><item>  super-&gt;set_data( it_data = gt_data ).</item><item>ENDMETHOD.</item></SET_DATA><FIND_ROOTNAME><item>  METHOD find_rootname.</item><item>    DATA: lt_rootname TYPE zsppp_ectr_norm_t,</item><item>          lv_lines    TYPE i.</item><item/><item>    LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;).</item><item>      lt_rootname = zcl_pp_ectr=&gt;get_bom_rootname( iv_aennr = &lt;ls_data&gt;-aennr</item><item>                                                   iv_matnr = &lt;ls_data&gt;-matnr</item><item>                                                   iv_sortf = &lt;ls_data&gt;-sortf_new</item><item>                                                   iv_stlan = &lt;ls_data&gt;-stlan</item><item>                                                   iv_stlal = &lt;ls_data&gt;-stlal ).</item><item>      DESCRIBE TABLE lt_rootname LINES lv_lines.</item><item>      IF ( lv_lines = 1 ).</item><item>        TRY.</item><item>            &lt;ls_data&gt;-rootname = lt_rootname[ 1 ]-rootname.</item><item>            &lt;ls_data&gt;-posid = lt_rootname[ 1 ]-posid.</item><item>            &lt;ls_data&gt;-dispo = lt_rootname[ 1 ]-dispo.</item><item>          CATCH cx_root.</item><item>        ENDTRY.</item><item>      ELSE.</item><item>        LOOP AT lt_rootname INTO DATA(ls_rootname).</item><item>          DATA: ls_data_2 TYPE ty_s_data.</item><item>          MOVE-CORRESPONDING &lt;ls_data&gt; TO ls_data_2.</item><item>          TRY.</item><item>              &lt;ls_data&gt;-rootname = gt_data[ rootname = ls_rootname-rootname ]-rootname.</item><item>              &lt;ls_data&gt;-posid = gt_data[ rootname = ls_rootname-rootname ]-posid.</item><item>              &lt;ls_data&gt;-dispo = gt_data[ rootname = ls_rootname-rootname ]-dispo.</item><item>            CATCH cx_root.</item><item>          ENDTRY.</item><item>        ENDLOOP.</item><item>      ENDIF.</item><item>    ENDLOOP.  &quot;LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;).</item><item/><item>    DELETE ADJACENT DUPLICATES FROM gt_data COMPARING rootname matnr idnrk.</item><item/><item>    DELETE gt_data WHERE rootname IS INITIAL.</item><item>    DELETE gt_data WHERE rootname NOT IN gs_sel-s_root.</item><item>    DELETE gt_data WHERE posid NOT IN gs_sel-s_posid.</item><item>    DELETE gt_data WHERE dispo NOT IN gs_sel-s_dispo.</item><item>  ENDMETHOD.</item></FIND_ROOTNAME><CREATE_PDM_NOR_BOM><item>METHOD create_pdm_nor_bom.</item><item/><item>  DATA: ls_pdm_nor_bom TYPE zpp_pdm_nor_bom.</item><item>  REFRESH: gt_pdm_nor_bom.</item><item/><item>* Recupero eventuali record non elaborati da elaborazioni precedenti</item><item>  SELECT * APPENDING CORRESPONDING FIELDS OF TABLE gt_pdm_nor_bom</item><item>           FROM zpp_pdm_nor_bom</item><item>           WHERE elaborato = abap_false.</item><item/><item>  LOOP AT gt_data INTO DATA(ls_data)</item><item>*   La presenza di record in gt_data senza ROOTNAME è un &quot;errore&quot; del progettista</item><item>*   che ha agito su un Padre senza, attualmente, un impegno  oppure</item><item>*   potrebbe trattarsi di un legame inserito e a seguire cancellato</item><item>*   Quando il Materiale avrà la possibilità di essere abbinato ad un Albero</item><item>*   il record sarà recuperato</item><item>    WHERE rootname IS NOT INITIAL.</item><item>    CLEAR: ls_pdm_nor_bom.</item><item>    MOVE-CORRESPONDING ls_data TO ls_pdm_nor_bom.</item><item>    ls_pdm_nor_bom-parentname = ls_data-matnr.</item><item>    ls_pdm_nor_bom-childname  = ls_data-idnrk.</item><item>    ls_pdm_nor_bom-relpos     = ls_data-posnr.</item><item>    APPEND ls_pdm_nor_bom TO gt_pdm_nor_bom.   &quot;&lt;------</item><item>  ENDLOOP.</item><item/><item>  IF ( gt_data[]        IS INITIAL AND</item><item>       gt_pdm_nor_bom[] IS NOT INITIAL ).</item><item>*   RAISE EXCEPTION TYPE zcx_bc_exception MESSAGE s019(zppp_ectr).</item><item/><item>*   Caricare la gt_data a partire dalla gt_pdm_nor_bom e dalla ZPP_MODBOM</item><item>    SELECT * INTO CORRESPONDING FIELDS OF TABLE gt_data</item><item>        FROM zpp_modbom</item><item>        FOR ALL ENTRIES IN gt_pdm_nor_bom</item><item>        WHERE matnr = gt_pdm_nor_bom-parentname</item><item>          AND idnrk = gt_pdm_nor_bom-childname</item><item>          AND relstartdate = gt_pdm_nor_bom-relstartdate</item><item>          AND relenddate   = gt_pdm_nor_bom-relenddate</item><item>          &quot;AND posnr  = gt_pdm_nor_bom-relpos</item><item>          AND relqty = gt_pdm_nor_bom-relqty.</item><item/><item>    DELETE ADJACENT DUPLICATES FROM gt_data COMPARING matnr idnrk relstartdate relenddate relqty.</item><item/><item>    DATA: lv_conta TYPE i.</item><item>    LOOP AT gt_data INTO ls_data</item><item>       WHERE rootname IS INITIAL.</item><item>      DATA(xtabix) = sy-tabix.</item><item>      CLEAR: lv_conta.</item><item>      LOOP AT gt_pdm_nor_bom INTO DATA(ls_nor_bom)</item><item>         WHERE parentname = ls_data-matnr</item><item>           AND childname  = ls_data-idnrk</item><item>           AND relstartdate = ls_data-relstartdate</item><item>           AND relenddate   = ls_data-relenddate</item><item>           AND relqty       = ls_data-relqty.</item><item>        ls_data-rootname = ls_nor_bom-rootname.</item><item>        IF lv_conta IS INITIAL.</item><item>          lv_conta = lv_conta + 1.</item><item>          MODIFY gt_data FROM ls_data INDEX xtabix TRANSPORTING rootname.</item><item>        ELSE.</item><item>          APPEND ls_data TO gt_data.</item><item>        ENDIF.</item><item>      ENDLOOP.</item><item>    ENDLOOP.</item><item/><item>    DATA: lv_rootname TYPE zpp_albero-rootname,</item><item>          lv_posid    TYPE prps-posid,</item><item>          lv_dispo    TYPE marc-dispo..</item><item>    CLEAR: lv_rootname, lv_posid, lv_dispo.</item><item/><item>    SORT gt_data BY rootname.</item><item/><item>*   Estrazione della WBS e del Resp.MRP</item><item>    LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;)</item><item>      WHERE rootname IS NOT  INITIAL</item><item>        AND ( posid IS INITIAL OR dispo IS INITIAL ).</item><item>      IF ( lv_rootname &lt;&gt; &lt;ls_data&gt;-rootname ).</item><item>        CLEAR: lv_posid, lv_dispo.</item><item>        get_wbs_dispo( EXPORTING iv_rootname = &lt;ls_data&gt;-rootname</item><item>                        CHANGING  cv_posid = lv_posid</item><item>                                  cv_dispo = lv_dispo ).</item><item>      ENDIF.</item><item>      &lt;ls_data&gt;-posid = lv_posid.</item><item>      &lt;ls_data&gt;-dispo = lv_dispo.</item><item>      lv_rootname = &lt;ls_data&gt;-rootname.</item><item>    ENDLOOP.   &quot;LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;).</item><item/><item>    SORT gt_data BY rootname matnr idnrk datum uzeit vbkz.</item><item/><item>  ENDIF.   &quot; IF ( gt_data[]        IS INITIAL AND ...</item><item/><item>  set_tables_fase_1( ).</item><item>  IF ( gs_sel-p_test = abap_false ).</item><item>    &quot;Aggiornamento Step 1 solo se non siamo in simulazione</item><item>    update_tables_fase_1( ).</item><item>  ENDIF.</item><item/><item>  alv_create( EXPORTING iv_title = &apos;TREE&apos;(002)</item><item>                        iv_layout = gs_sel-p_layo2</item><item>                        iv_pfstatus = &apos;STANDARD_FULLSCREEN2&apos;</item><item>              CHANGING ct_data = gt_pdm_nor_bom ).</item><item>  IF ( iv_show_alv = abap_true ).</item><item>    me-&gt;alv_show( ).</item><item>  ENDIF.</item><item>ENDMETHOD.</item></CREATE_PDM_NOR_BOM><CREATE_TREE_OLD><item>  METHOD create_tree_old.</item><item>    create_pdm_nor_bom( ).</item><item>    alv_create( EXPORTING iv_title = &apos;TREE&apos;(002)</item><item>                          iv_layout = gs_sel-p_layo2</item><item>                          iv_pfstatus = &apos;STANDARD_FULLSCREEN2&apos;</item><item>                CHANGING ct_data = gt_pdm_nor_bom ).</item><item>    IF ( iv_show_alv = abap_true ).</item><item>      me-&gt;alv_show( ).</item><item>    ENDIF.</item><item>  ENDMETHOD.</item></CREATE_TREE_OLD><SET_TABLES_FASE_1><item>  METHOD set_tables_fase_1.</item><item>    LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;) WHERE zflag2 = abap_false.</item><item>      &lt;ls_data&gt;-zflag2 = abap_true.</item><item>    ENDLOOP.</item><item/><item>    gv_fase = 1.</item><item>  ENDMETHOD.</item></SET_TABLES_FASE_1><UPDATE_TABLES_FASE_1><item>METHOD update_tables_fase_1.</item><item>  DATA: lt_modbom      TYPE TABLE OF zpp_modbom,</item><item>        lt_pdm_nor_bom TYPE TABLE OF zpp_pdm_nor_bom,</item><item>        ls_modbom      TYPE zpp_modbom,</item><item>        ls_pdm_nor_bom TYPE zpp_pdm_nor_bom,</item><item>        lv_zflag2      TYPE zpp_modbom-zflag2.</item><item/><item>  REFRESH: lt_modbom, lt_pdm_nor_bom.</item><item/><item>  MOVE-CORRESPONDING gt_pdm_nor_bom TO lt_pdm_nor_bom.</item><item/><item>  LOOP AT gt_data INTO DATA(ls_data) WHERE zflag2  = abap_true</item><item>                                       &quot; è un record che esiste sulla ZPP_MODBOM</item><item>                                       AND to_save = abap_true.</item><item>    IF ls_data-rootname IS INITIAL.</item><item>      &quot;Warning: non è stato possibile determinare il ROOTNAME</item><item>      &quot;Non è un errore perchè quando il Materiale avrà la possibilità di</item><item>      &quot;essere abbinato ad un Albero il record sarà recuperato oppure</item><item>      &quot;potrebbe trattarsi di un legame inserito e a seguire cancellato</item><item>      lv_zflag2 = &apos;W&apos;.</item><item>    ELSE.</item><item>      lv_zflag2 = abap_true.</item><item>    ENDIF.</item><item>    UPDATE zpp_modbom SET zflag2 = lv_zflag2 WHERE aennr        = ls_data-aennr</item><item>                                             AND   stlan        = ls_data-stlan</item><item>                                             AND   datum        = ls_data-datum</item><item>                                             AND   uzeit        = ls_data-uzeit</item><item>                                             AND   matnr        = ls_data-matnr</item><item>                                             AND   posnr        = ls_data-posnr</item><item>                                             AND   pspnr        = ls_data-pspnr</item><item>                                             AND   idnrk        = ls_data-idnrk</item><item>                                             AND   werks        = ls_data-werks</item><item>                                             AND   stlal        = ls_data-stlal</item><item>                                             AND   vbkz         = ls_data-vbkz</item><item>                                             AND   oitxt        = ls_data-oitxt</item><item>                                             AND   relstartdate = ls_data-relstartdate</item><item>                                             AND   relenddate   = ls_data-relenddate.</item><item>  ENDLOOP.</item><item/><item>  IF lt_pdm_nor_bom[] IS NOT INITIAL.</item><item>    MODIFY zpp_pdm_nor_bom FROM TABLE lt_pdm_nor_bom.</item><item>  ENDIF.</item><item/><item>  COMMIT WORK AND WAIT.</item><item>ENDMETHOD.</item></UPDATE_TABLES_FASE_1><SET_TABLES_FASE_2><item>  METHOD set_tables_fase_2.</item><item>    DATA: ls_pdm_mon_anag TYPE ty_s_pdm_mon_anag,</item><item>          ls_pdm_mon_bom  TYPE ty_s_pdm_mon_bom.</item><item/><item>    LOOP AT gt_pdm_nor_bom INTO DATA(ls_pdm_nor_bom).</item><item>      DATA(lv_tabix) = sy-tabix.</item><item>      CLEAR: ls_pdm_mon_anag, ls_pdm_mon_bom.</item><item/><item>      MOVE-CORRESPONDING ls_pdm_nor_bom TO ls_pdm_mon_anag.</item><item>      ls_pdm_mon_anag-mandt = sy-mandt.</item><item>      ls_pdm_mon_anag-tipofile = 20.</item><item>      ls_pdm_mon_anag-datum = sy-datum.</item><item>      ls_pdm_mon_anag-uzeit = sy-uzeit.</item><item>      ls_pdm_mon_anag-codename = ls_pdm_nor_bom-childname.</item><item>      ls_pdm_mon_anag-codeqty = 1.</item><item>      DATA: ls_modbom TYPE zpp_modbom.</item><item>      CLEAR: ls_modbom.</item><item>*      IF ( NOT gt_data[] IS INITIAL ).</item><item>      DATA: lt_data TYPE TABLE OF zpp_modbom.</item><item>      MOVE-CORRESPONDING gt_data TO lt_data.</item><item>      TRY.</item><item>          ls_modbom = lt_data[ matnr        = ls_pdm_nor_bom-rootname</item><item>                               relstartdate = ls_pdm_nor_bom-relstartdate</item><item>                               relenddate   = ls_pdm_nor_bom-relenddate</item><item>                               posnr        = ls_pdm_nor_bom-relpos+1(4)</item><item>                               relqty       = ls_pdm_nor_bom-relqty ].</item><item>        CATCH cx_root.</item><item>          SELECT * INTO CORRESPONDING FIELDS OF ls_modbom</item><item>                   FROM zpp_modbom</item><item>                   WHERE matnr        = ls_pdm_nor_bom-rootname</item><item>                   AND   relstartdate = ls_pdm_nor_bom-relstartdate</item><item>                   AND   relenddate   = ls_pdm_nor_bom-relenddate</item><item>                   AND   posnr        = ls_pdm_nor_bom-relpos+1(4)</item><item>                   AND   relqty       = ls_pdm_nor_bom-relqty</item><item>                   AND   zflag1       = abap_true</item><item>                   AND   zflag2       = abap_true</item><item>                         ORDER BY datum DESCENDING uzeit DESCENDING.</item><item>            EXIT.</item><item>          ENDSELECT.</item><item>      ENDTRY.</item><item>      MOVE-CORRESPONDING ls_pdm_nor_bom TO ls_pdm_mon_bom.</item><item/><item>      ls_pdm_mon_bom-mandt = sy-mandt.</item><item>      ls_pdm_mon_bom-tipofile = 23.</item><item>      ls_pdm_mon_bom-datum = sy-datum.</item><item>      ls_pdm_mon_bom-uzeit = sy-uzeit.</item><item>      ls_pdm_mon_bom-counter = lv_tabix.</item><item>      APPEND ls_pdm_mon_bom TO gt_pdm_mon_bom.   &quot;&lt;------</item><item/><item>      TRY.</item><item>          DATA(ls_data) = gt_data[ rootname = ls_pdm_mon_anag-rootname</item><item>                                   idnrk    = ls_pdm_mon_anag-codename ].</item><item>*           Non importa se il record è stato determinato dall&apos;algoritmo in laterale</item><item>*                                  to_save  = abap_true ].</item><item>          APPEND ls_pdm_mon_anag TO gt_pdm_mon_anag.   &quot;&lt;------</item><item>        CATCH cx_root.</item><item>      ENDTRY.</item><item>    ENDLOOP.</item><item/><item>    LOOP AT gt_pdm_mon_anag ASSIGNING FIELD-SYMBOL(&lt;ls_pdm_mon_anag&gt;).</item><item>      lv_tabix = sy-tabix.</item><item>      &lt;ls_pdm_mon_anag&gt;-counter = lv_tabix.</item><item>      TRY.</item><item>          DATA(ls_data_2) = gt_data[ rootname = &lt;ls_pdm_mon_anag&gt;-rootname</item><item>                                     idnrk    = &lt;ls_pdm_mon_anag&gt;-codename ].</item><item>*           Non importa se il record è stato determinato dall&apos;algoritmo in laterale</item><item>*                                    to_save  = abap_true ].</item><item>          IF ( ls_data-aennr IS INITIAL ).</item><item>            IF ( NOT ls_data-sortf_new IS INITIAL ).</item><item>              &lt;ls_pdm_mon_anag&gt;-opname = ls_data-sortf_new.</item><item>            ELSE.</item><item>              &lt;ls_pdm_mon_anag&gt;-opname = ls_data-sortf_old.</item><item>            ENDIF.</item><item>          ELSE.</item><item>            &lt;ls_pdm_mon_anag&gt;-opname = ls_data-aennr.</item><item>          ENDIF.</item><item>        CATCH cx_root.</item><item>      ENDTRY.</item><item>    ENDLOOP.</item><item/><item>    gv_fase = 2.</item><item>  ENDMETHOD.</item></SET_TABLES_FASE_2><UPDATE_TABLES_FASE_2><item>  METHOD update_tables_fase_2.</item><item>    DELETE ADJACENT DUPLICATES FROM gt_pdm_mon_anag COMPARING rootname codename.</item><item/><item>    LOOP AT gt_pdm_nor_bom INTO DATA(ls_pdm_nor_bom) WHERE elaborato = abap_false.</item><item>      UPDATE zpp_pdm_nor_bom SET elaborato = abap_true WHERE parentname    = ls_pdm_nor_bom-parentname</item><item>                                                       AND   childname     = ls_pdm_nor_bom-childname</item><item>                                                       AND   rootname      = ls_pdm_nor_bom-rootname</item><item>                                                       AND   relstartdate  = ls_pdm_nor_bom-relstartdate</item><item>                                                       AND   relenddate    = ls_pdm_nor_bom-relenddate.</item><item>    ENDLOOP.</item><item/><item>    MODIFY zpp_pdm_mon_anag FROM TABLE gt_pdm_mon_anag.</item><item/><item>    MODIFY zpp_pdm_mon_bom FROM TABLE gt_pdm_mon_bom.</item><item/><item>    COMMIT WORK AND WAIT.</item><item>  ENDMETHOD.</item></UPDATE_TABLES_FASE_2><SEND_TO_TREE><item>  METHOD send_to_tree.</item><item/><item>*   Valorizzazione delle tabelle interne gt_pdm_mon_anag e gt_pdm_mon_bom</item><item>    set_tables_fase_2( ).</item><item/><item>    IF ( gs_sel-p_test = abap_true ).</item><item>      RAISE EXCEPTION TYPE zcx_bc_exception MESSAGE s020(zppp_ectr).</item><item>    ENDIF.</item><item/><item>    IF ( gs_sel-p_test = abap_false ).</item><item>*     Valorizzazione delle tabelle ZPP_PDM_MON_ANAG e ZPP_PDM_MON_BOM</item><item>      update_tables_fase_2( ).</item><item>    ENDIF.</item><item/><item>  ENDMETHOD.</item></SEND_TO_TREE><GET_CURRENT_FASE><item>  METHOD get_current_fase.</item><item>    rv_ret = gv_fase.</item><item>  ENDMETHOD.</item></GET_CURRENT_FASE><FIND_ROOTNAME_2><item>  METHOD find_rootname_2.</item><item/><item>*   Algoritmo di propagazione verso il basso :</item><item>*     Determina i ROOTNAME. Con questi codici esplosione della BOM Multilivello</item><item>*     tramite ZCL_PP_ECTR METHOD get_bom.</item><item>*   REM: Il metodo get_bom esplode la bom via FM CS_BOM_EXPL_MAT_V2 con data odierna</item><item>*        quindi eventuali modifiche alla BOM eseguite con change number 5*</item><item>*        non sono visibili perchè attive nel 31/12/3000</item><item>*   Se emergono nuovi legami allora RELSTARTDATE e RELENDDATE determinati:</item><item>*   - lettura della ZPP_PDM_NOR_BOM per estrarre l&apos;ultimo record con RELENDDATE = 31/12/2099 00:00:00</item><item>*   - se nessun record è presente sulla ZPP_PDM_NOR_BOM allora lettura della ZPP_MODBOM</item><item>*     per estrarre l&apos;ultimo record con RELENDDATE = 31/12/2099 00:00:00</item><item>*</item><item>*   Estrazione della WBS dalla tabella ZPS_WBS_APERTE</item><item>*   Elaborazione dei legami : SCHELETRO o con MATNR(1) in (&apos;K&apos;, &apos;6&apos;)</item><item>    find_rootname_sch( ).</item><item/><item>*   I record sulla gt_data dettagliano il legame Padre-Componente e se duplicati per Padre-Componente</item><item>*   allora solo l&apos;ultimo sarà significativo per gli algoritmi di propagazione laterale/profondità.</item><item>*   Mentre il risultato della propagazione andrà applicato su tutti i record e sempre</item><item>*   su tutti i record avremo il passaggio nella tabella ZPP_PDM_MON_BOM</item><item>*</item><item>*   Determinare l&apos;elenco dei ROOTNAME dalla classificazione del change number 5*</item><item>*   Algoritmo di propagazione in laterale ( a partità di change number ) serve per identificare</item><item>*   tutti i ROOTNAME coinvolti da ogni legame Padre-Componente cioè serve per</item><item>*   verificare se tale elenco di ROOTNAME è esaustivo o il progettista ne ha dimentico qualcuno.</item><item>*   Per ogni legame Padre-Componente accedere alla tabella ZPP_PDM_NOR_BOM con:</item><item>*     ROOTNAME &lt;&gt; dai ROOTNAME della classificazione e CHILDNAME = Padre e RELENDDATE = 31/12/2099 00:00:00</item><item>*     Ordinare i N record estratti per ROOTNAME PARENTNAME CHILDNAME RELSTARTDATE (opportunamente divisa in DATA e ORA)</item><item>*     RELENDDATE DESCENDING (opportunamente divisa in DATA e ORA) e prendere l&apos;ultimo record.</item><item>*     Se l&apos;ultimo record ha RELENDDATE = 31/12/2099 00:00:00 allora il legame è valido e quindi il ROOTNAME trovato</item><item>*     è corretto ( il progettista ha dimenticato un ROOTNAME ).</item><item>*    Vedi metodi: ZCL_PP_ECTR_NORM ECTR get_active_components e ZCL_PP_ECTR get_active_nodes</item><item>*   Arriviamo quindi ad avere N ROOTNAME e ogni record della gt_data dovrà essere opportunamente</item><item>*   duplicato per i suoi ROOTNAME</item><item>*</item><item>*   Algoritmo di propagazione verso il basso ( a partità di change number e ROOTNAME ) :</item><item>*     per tutti i Componenti (IDNRK) che sono foglie nella gt_data cioè non sono presenti</item><item>*     come MATNR in gt_data verificare che siano:</item><item>*     - ZMTO (MARC-DISGR)</item><item>*     - MARC-BESKZ = E oppure</item><item>*     - MARC-BESKZ = F e MARC-SOBSL = 30</item><item>*     - il legame Padre (MATNR) Figlio (IDNRK) deve essere di inserimento (ricordiamo che dato un legame</item><item>*       MATNR IDNRK posso avere N record in GT_DATA perchè questo legame potrebbe essere stato cancellato, ripristinato,</item><item>*       modificato e questo più volte)</item><item>*     - il ROOTNAME non deve essere già stato elaborato come SCHELETRO</item><item>*     allora esplosione della eventuale BOM Multilivello della foglia tramite ZCL_PP_ECTR METHOD get_bom.</item><item>*   Potenzialmente si aggiungono record alla gt_data</item><item>*   Arriviamo quindi ad avere M legami Padre-Componente</item><item>*</item><item>*   Si deve garantire che in tabella gt_data ci siano tutti gli N * M legami</item><item>*</item><item>*   Nota: i ROOTNAME validi devono essere presenti nella tabella ZPS_WBS_APERTE</item><item>*   Elaborazione dei legami da CAD Meccanico</item><item>    find_rootname_mec( ).</item><item/><item>*   Elaborazione dei legami da CAD Elettrico con le stesse logiche del CAD Meccanico</item><item>    find_rootname_ele( ).</item><item/><item>*    SORT gt_data BY rootname datum uzeit.</item><item>    gv_fase = 0.</item><item/><item>    delete_duplicates( ).</item><item>  ENDMETHOD.</item></FIND_ROOTNAME_2><FIND_ROOTNAME_ELE><item>METHOD find_rootname_ele.</item><item>  TYPES: BEGIN OF ty_s_aennr,</item><item>           aennr TYPE aennr,</item><item>         END OF ty_s_aennr.</item><item>  TYPES: ty_t_aennr    TYPE TABLE OF ty_s_aennr.</item><item/><item>  DATA: lt_aennr TYPE ty_t_aennr,</item><item>        ls_aennr TYPE ty_s_aennr.</item><item/><item>  DATA: lt_rootname TYPE ty_t_rootname,</item><item>        lv_lines    TYPE i.</item><item/><item>  REFRESH: lt_aennr.</item><item>  BREAK kosmedev.</item><item>  DATA: lv_prefix    TYPE string,</item><item>        lt_rootname2 TYPE zsppp_ectr_norm_t.</item><item/><item>  lv_prefix = zcl_pp_ectr=&gt;c_elettrico.  &quot;&apos;BOM-&apos;.</item><item/><item>* Estrazione dei change number con prefisso 5* (CAD Meccanico)</item><item>  REFRESH: lt_rootname, lt_rootname2.</item><item>  LOOP AT gt_data INTO DATA(ls_data) WHERE aennr(4)     = lv_prefix.</item><item>*   Non attivare il seguente filtro perchè la radice del change number è già condizione necessaria e sufficiente</item><item>*                                    AND   sortf_new(1) = &apos;E&apos;.</item><item>    CLEAR: ls_aennr.</item><item>    MOVE-CORRESPONDING ls_data TO ls_aennr.</item><item>    DATA: ls_rootname  TYPE ty_s_rootname,</item><item>          ls_rootnames TYPE ty_s_rootnames,</item><item>          ls_rootname2 TYPE zsppp_ectr_norm.</item><item>    CLEAR: ls_rootname, ls_rootnames, ls_rootname2.</item><item>    ls_rootname-aennr = ls_data-aennr.</item><item>    IF ( NOT ls_data-sortf_new IS INITIAL ).</item><item>      ls_rootname-rootname = ls_rootnames-rootname = ls_rootname2-rootname = ls_data-sortf_new+1(9).</item><item>    ELSEIF ( NOT ls_data-sortf_old IS INITIAL ).</item><item>      ls_rootname-rootname = ls_rootnames-rootname = ls_rootname2-rootname = ls_data-sortf_old+1(9).</item><item>    ENDIF.</item><item/><item>    CONDENSE: ls_rootname-rootname, ls_rootname2-rootname.</item><item>    COLLECT: ls_rootname INTO lt_rootname, ls_rootnames INTO gt_rootnames, ls_rootname2 INTO lt_rootname2.</item><item>    COLLECT ls_aennr INTO lt_aennr.   &quot;&lt;------</item><item>  ENDLOOP.</item><item/><item>*   Algoritmo in laterale che potenzialmente :</item><item>*   - aggiunge record in lt_rootname</item><item>*   - inserisce e aggiorna record in gt_data</item><item>*   Prima si utilizzano i legami attivi in ZPP_PDM_NOR_BOM per recuperare il ROOTNAME</item><item>*   lt_pdm_nor_bom con i nuovi record validi. Al momento non utilizzata</item><item>* Elabora i record di gt_data senza ROOTNAME</item><item>  DATA(lt_pdm_nor_bom) = get_active_components( EXPORTING iv_prefix   = lv_prefix</item><item>                                                CHANGING  ct_rootname = lt_rootname ).   &quot;&lt;------ Elenco ROOTNAME da Change Number</item><item/><item>  &quot; Algoritmo in profondità</item><item>  TYPES: BEGIN OF ty_s_data_local.</item><item>  TYPES:   group TYPE i.</item><item>      INCLUDE TYPE ty_s_data.</item><item>  TYPES: END OF ty_s_data_local.</item><item>  TYPES: ty_t_data_local TYPE TABLE OF ty_s_data_local.</item><item/><item>  DATA: lt_data       TYPE ty_t_data,       &quot;tabella di appoggio in cui copio la gt_data</item><item>        lt_data_i     TYPE ty_t_data_local, &quot;tabella con tutti gli inserimenti</item><item>        lt_data_u     TYPE ty_t_data_local, &quot;tabella con tutte le modifiche (coppie I-D raggruppate per group)</item><item>        lt_data_d     TYPE ty_t_data_local, &quot;tabella delle cancellazioni</item><item>        ls_data_local TYPE ty_s_data_local,</item><item>        lv_group_i    TYPE i,</item><item>        lv_group_u    TYPE i,</item><item>        lv_group_d    TYPE i.</item><item/><item>  CLEAR: lt_data_i, lt_data_u, lt_data_d.</item><item>  lv_group_i = lv_group_u = lv_group_d = 1.</item><item>  lt_data[] = gt_data[].</item><item>  SORT lt_data BY rootname matnr idnrk datum uzeit vbkz.</item><item>  DELETE lt_data WHERE aennr(4) &lt;&gt; lv_prefix.</item><item>* Valorizzare le tabelle interne lt_data_*  ma solo la lt_data_i sarà a seguire utilizzata</item><item>  LOOP AT lt_data INTO ls_data WHERE aennr(4) = lv_prefix.</item><item>    DATA(lv_tabix) = sy-tabix.</item><item>    TRY.</item><item>*        DATA(ls_data_2) = gt_rootnames[ rootname = ls_data-rootname ].</item><item>        &quot; verifica se il nodo è foglia</item><item>        DATA(ls_data_2) = gt_data[ aennr = ls_data-aennr</item><item>                                   rootname = ls_data-rootname</item><item>                                   matnr = ls_data-idnrk ].</item><item>        DELETE lt_data.</item><item/><item>      CATCH cx_root.</item><item/><item>        SELECT SINGLE matnr INTO @DATA(lv_matnr)</item><item>               FROM marc</item><item>               WHERE werks = @zcl_pp_ectr=&gt;c_werks  &quot;6301</item><item>               AND   matnr = @ls_data-idnrk</item><item>               AND   disgr = @zcl_pp_ectr=&gt;c_disgr  &quot;ZMTO</item><item>               AND ( beskz = &apos;E&apos; OR ( beskz = &apos;F&apos; AND sobsl = &apos;30&apos; ) ).</item><item>        IF ( sy-subrc = 0 ).</item><item>          CASE ls_data-vbkz.</item><item>            WHEN &apos;D&apos;.</item><item>              READ TABLE lt_data INTO ls_data_2 WITH KEY rootname     = ls_data-rootname</item><item>                                                         matnr        = ls_data-matnr</item><item>                                                         idnrk        = ls_data-idnrk</item><item>                                                         relstartdate = ls_data-relstartdate</item><item>                                                         relenddate   = zcl_pp_ectr=&gt;c_infinite_date  &quot;31/12/2099 00:00:00</item><item>                                                         vbkz         = &apos;I&apos;.</item><item>              IF ( sy-subrc = 0 ).</item><item>                DATA(lv_tabix_2) = sy-tabix.</item><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_u.</item><item>                APPEND ls_data_local TO lt_data_u.   &quot;&lt;------</item><item/><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_u.</item><item>                APPEND ls_data_local TO lt_data_u.   &quot;&lt;------</item><item>                ADD 1 TO lv_group_u.</item><item/><item>                DELETE lt_data INDEX lv_tabix_2.</item><item>                IF ( lv_tabix &gt; lv_tabix_2 ).</item><item>                  DELETE lt_data INDEX lv_tabix_2.</item><item>                ELSE.</item><item>                  DELETE lt_data INDEX lv_tabix.</item><item>                ENDIF.</item><item>              ELSE.</item><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_d.</item><item>                APPEND ls_data_local TO lt_data_d.   &quot;&lt;------</item><item>                ADD 1 TO lv_group_d.</item><item/><item>                DELETE lt_data INDEX lv_tabix.</item><item>              ENDIF.</item><item>              CONTINUE.</item><item/><item>            WHEN &apos;I&apos;.</item><item>              READ TABLE lt_data INTO ls_data_2 WITH KEY rootname     = ls_data-rootname</item><item>                                                         matnr        = ls_data-matnr</item><item>                                                         idnrk        = ls_data-idnrk</item><item>                                                         relstartdate = ls_data-relstartdate</item><item>                                                         vbkz         = &apos;D&apos;.</item><item>              IF ( sy-subrc = 0 ).</item><item>                lv_tabix_2 = sy-tabix.</item><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_u.</item><item>                APPEND ls_data_local TO lt_data_u.   &quot;&lt;------</item><item/><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_u.</item><item>                APPEND ls_data_local TO lt_data_u.   &quot;&lt;------</item><item>                ADD 1 TO lv_group_u.</item><item/><item>                DELETE lt_data INDEX lv_tabix_2.</item><item>                IF ( lv_tabix &gt; lv_tabix_2 ).</item><item>                  DELETE lt_data INDEX lv_tabix_2.</item><item>                ELSE.</item><item>                  DELETE lt_data INDEX lv_tabix.</item><item>                ENDIF.</item><item>              ELSE.</item><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_i.</item><item>                APPEND ls_data_local TO lt_data_i.   &quot;&lt;------</item><item>                ADD 1 TO lv_group_i.</item><item/><item>                DELETE lt_data INDEX lv_tabix.</item><item>              ENDIF.</item><item>              CONTINUE.</item><item/><item>          ENDCASE.</item><item>        ENDIF.</item><item>        DELETE lt_data INDEX lv_tabix.</item><item>        CONTINUE.</item><item>    ENDTRY.</item><item>  ENDLOOP.   &quot;LOOP AT lt_data INTO ls_data WHERE aennr(4) = lv_prefix.</item><item/><item>  DATA: lt_data_leaf TYPE ty_t_data.</item><item>  REFRESH: lt_data_leaf.</item><item>  LOOP AT gt_data INTO ls_data WHERE aennr(4) = lv_prefix.</item><item>*                                 AND   sortf_new(1) = &apos;E&apos;.</item><item>    TRY.</item><item>        ls_data_local = lt_data_i[ rootname     = ls_data-rootname</item><item>                                   matnr        = ls_data-matnr</item><item>                                   idnrk        = ls_data-idnrk</item><item>                                   relstartdate = ls_data-relstartdate ].</item><item>*        CATCH cx_root.</item><item>        DATA(ls_bom) = zcl_pp_ectr=&gt;get_bom( iv_capid = &apos;PC01&apos;</item><item>                                             iv_datuv = sy-datum</item><item>                                             iv_matnr = ls_data-idnrk</item><item>                                             iv_ememg = 1</item><item>                                             iv_mehrs = abap_true</item><item>                                             iv_stlan = ls_data-stlan</item><item>                                             iv_stlal = ls_data-stlal</item><item>                                             iv_mto   = abap_true ).</item><item>        LOOP AT ls_bom-t_stb INTO DATA(ls_stb).</item><item>*            READ TABLE gt_data INTO ls_data WITH KEY rootname = ls_pdm_nor_bom-rootname</item><item>          READ TABLE gt_data INTO ls_data WITH KEY rootname = ls_data-rootname</item><item>                                                   matnr    = ls_stb-baugr   &quot;Padre</item><item>                                                   idnrk    = ls_stb-idnrk.  &quot;Componente</item><item>          IF ( sy-subrc = 0 ).</item><item>*                &quot; Caso 1. Legame Padre-Componente è già sulla gt_data</item><item>*                ls_data = gt_data[ matnr = ls_stb-baugr idnrk = ls_stb-idnrk ].</item><item>*                DATA(lv_tabix) = sy-tabix.</item><item>*                ls_data-rootname = ls_pdm_nor_bom-rootname.</item><item>*                ls_data-posid = lt_rootname[ aennr = ls_data-aennr</item><item>*                                             rootname = ls_data-rootname ]-posid.</item><item>*                ls_data-dispo = lt_rootname[ aennr = ls_data-aennr</item><item>*                                             rootname = ls_data-rootname ]-dispo.</item><item>*                ls_data-to_save = abap_true.         &quot;Flag per indicare che il record sarà salvato in ZPP_MODBOM</item><item>*                MODIFY gt_data FROM ls_data INDEX lv_tabix TRANSPORTING rootname posid dispo to_save.</item><item>          ELSE.</item><item>            &quot; Caso 2. Legame Padre-Componente non presente sulla gt_data</item><item>            CLEAR: ls_data.</item><item>*                  ls_data = gt_data[ idnrk = ls_stb-baugr ].</item><item>            TRY.</item><item>                ls_data = gt_data[ idnrk = ls_stb-baugr ].</item><item>              CATCH cx_root.</item><item>                ls_data = lt_data_leaf[ idnrk = ls_stb-baugr ].</item><item>            ENDTRY.</item><item>            CLEAR: ls_data-relstartdate, ls_data-relenddate.</item><item>            MOVE-CORRESPONDING ls_stb TO ls_data.</item><item>            ls_data-mandt = sy-mandt.</item><item>*              ls_data-rootname = ls_pdm_nor_bom-rootname.</item><item>            ls_data-rootname = ls_data_local-rootname. &quot;ls_data-rootname.</item><item>            ls_data-posid = space.</item><item>            ls_data-dispo = space.</item><item>            ls_data-matnr = ls_stb-baugr.</item><item>            ls_data-idnrk = ls_stb-idnrk.</item><item>            ls_data-relqty = ls_stb-menge.</item><item>*              ls_data-posid = lt_rootname[ aennr = ls_data-aennr</item><item>*                                           rootname = ls_data-rootname ]-posid.</item><item>*              ls_data-dispo = lt_rootname[ aennr = ls_data-aennr</item><item>*                                           rootname = ls_data-rootname ]-dispo.</item><item>            &quot; Le date RELSTARTDATE e RELENDDATE devono essere recuperate dalla ZPP_PDM_NOR_BOM sull&apos;ultimo record</item><item>            &quot; a parità di PARENTNAME ( ls_data-matnr )  / CHILDNAME ( ls_data-idnrk ) / ROOTNAME ( ls_data-rootname )</item><item>            &quot; Quindi il MAX ( RELSTARTDATE )</item><item>            &quot; ...</item><item/><item>            &quot; Se nessun record è presente sulla ZPP_PDM_NOR_BOM allora lettura ZPP_MODBOM</item><item>            &quot; essendo un legame da BOM SCHELTRO avremo un solo record</item><item>            &quot; ...</item><item/><item>            zcl_pp_ectr=&gt;get_bom_dates( EXPORTING iv_rootname   = ls_data-rootname</item><item>                                                  iv_parentname = ls_data-matnr</item><item>                                                  iv_childname  = ls_data-idnrk</item><item>                                        CHANGING  cv_relstartdate = ls_data-relstartdate</item><item>                                                  cv_relenddate   = ls_data-relenddate</item><item>                                                  cv_datum        = ls_data-datum</item><item>                                                  cv_uzeit        = ls_data-uzeit ).</item><item/><item>            ls_data-vbkz = &apos;I&apos;.</item><item>            ls_data-to_save = abap_false.         &quot;Flag per indicare che il record non sarà salvato in ZPP_MODBOM</item><item>*              IF ( zcl_pp_ectr=&gt;contains( is_data = ls_data it_data = gt_data[] ) &lt;&gt; 0 ).</item><item>            IF ( NOT line_exists( gt_data[ table_line = ls_data ] ) ).</item><item>              APPEND ls_data TO lt_data_leaf.   &quot;&lt;------</item><item>            ENDIF.</item><item>          ENDIF.</item><item>        ENDLOOP.  &quot;LOOP AT ls_bom-t_stb INTO DATA(ls_stb).</item><item>      CATCH cx_root.</item><item/><item>    ENDTRY.</item><item>  ENDLOOP.</item><item>  APPEND LINES OF lt_data_leaf TO gt_data.   &quot;&lt;------</item><item/><item>  DATA: lv_rootname TYPE zpp_albero-rootname,</item><item>        lv_posid    TYPE prps-posid,</item><item>        lv_dispo    TYPE marc-dispo..</item><item>  CLEAR: lv_rootname, lv_posid, lv_dispo.</item><item/><item>  SORT gt_data BY rootname.</item><item/><item>* Estrazione della WBS e del Resp.MRP</item><item>  LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;)</item><item>                  WHERE rootname IS NOT  INITIAL</item><item>      AND ( posid IS INITIAL OR dispo IS INITIAL ).</item><item>    IF ( lv_rootname &lt;&gt; &lt;ls_data&gt;-rootname ).</item><item>      CLEAR: lv_posid, lv_dispo.</item><item>      get_wbs_dispo( EXPORTING iv_rootname = &lt;ls_data&gt;-rootname</item><item>                      CHANGING  cv_posid = lv_posid</item><item>                                cv_dispo = lv_dispo ).</item><item>    ENDIF.</item><item>    &lt;ls_data&gt;-posid = lv_posid.</item><item>    &lt;ls_data&gt;-dispo = lv_dispo.</item><item>    lv_rootname = &lt;ls_data&gt;-rootname.</item><item>  ENDLOOP.   &quot;LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;).</item><item/><item>  SORT gt_data BY rootname matnr idnrk datum uzeit vbkz.</item><item/><item>  delete_duplicates( ).</item><item>ENDMETHOD.</item></FIND_ROOTNAME_ELE><FIND_ROOTNAME_MEC><item>METHOD find_rootname_mec.</item><item/><item>  TYPES: BEGIN OF ty_s_aennr,</item><item>           aennr TYPE aennr,</item><item>         END OF ty_s_aennr.</item><item>  TYPES: ty_t_aennr    TYPE TABLE OF ty_s_aennr.</item><item/><item>  DATA: lt_aennr TYPE ty_t_aennr,</item><item>        ls_aennr TYPE ty_s_aennr.</item><item/><item>  DATA: lt_rootname TYPE ty_t_rootname,</item><item>        lv_lines    TYPE i.</item><item/><item>  REFRESH: lt_aennr.</item><item/><item>* Estrazione del prefisso 5* (CAD Meccanico) da tabella di parametrizzazione ZTPP000</item><item>  TRY.</item><item>      DATA: lv_prefix TYPE string.</item><item>      &quot; ritorna lo stato del change number in cui è possibile il trasferimento del file</item><item>      &quot; il parametro di importing ev_prefix rappresenta il numero iniziale del change number</item><item>*      DATA(lv_aenst) = zcl_pp_ectr=&gt;get_cad_mec_bom_status( IMPORTING ev_prefix = lv_prefix ).</item><item>      zcl_pp_ectr=&gt;get_cad_mec_bom_status( IMPORTING ev_prefix = lv_prefix ).</item><item>      lv_prefix = lv_prefix.</item><item>    CATCH cx_root.</item><item>  ENDTRY.</item><item/><item>* Estrazione dei change number con prefisso 5* (CAD Meccanico)</item><item>  LOOP AT gt_data INTO DATA(ls_data) WHERE aennr(1) = lv_prefix.</item><item>    CLEAR: ls_aennr.</item><item>    MOVE-CORRESPONDING ls_data TO ls_aennr.</item><item>    COLLECT ls_aennr INTO lt_aennr.   &quot;&lt;------</item><item>  ENDLOOP.</item><item/><item>* Estrazione dei ROOTNAME dalla relativa classificazione BAPI_OBJCL_GETDETAIL</item><item>  REFRESH: lt_rootname.</item><item>  LOOP AT lt_aennr INTO ls_aennr.</item><item>    DATA(lt_rootname2) = zcl_pp_ectr=&gt;get_bom_mec_rootname( ls_aennr-aennr ).</item><item>    LOOP AT lt_rootname2 INTO DATA(ls_rootname2).</item><item>      DATA: ls_rootname TYPE ty_s_rootname.</item><item>      CLEAR: ls_rootname.</item><item>      MOVE-CORRESPONDING ls_aennr TO ls_rootname.</item><item>      MOVE-CORRESPONDING ls_rootname2 TO ls_rootname.</item><item>      COLLECT ls_rootname INTO lt_rootname.    &quot;&lt;------ Elenco ROOTNAME da Change Number</item><item>      DATA: ls_rootnames TYPE ty_s_rootnames.</item><item>      MOVE-CORRESPONDING ls_rootname TO ls_rootnames.</item><item>      COLLECT ls_rootnames INTO gt_rootnames.  &quot;&lt;------ Elenco ROOTNAME da Change Number</item><item>    ENDLOOP.</item><item>  ENDLOOP.   &quot;LOOP AT lt_aennr INTO ls_aennr.</item><item/><item>*   Algoritmo in laterale che potenzialmente :</item><item>*   - aggiunge record in lt_rootname</item><item>*   - inserisce e aggiorna record in gt_data</item><item>*   Prima si utilizzano i legami attivi in ZPP_PDM_NOR_BOM per recuperare il ROOTNAME</item><item>*   lt_pdm_nor_bom con i nuovi record validi. Al momento non utilizzata</item><item>* Elabora i record di gt_data senza ROOTNAME</item><item>  DATA(lt_pdm_nor_bom) = get_active_components( EXPORTING iv_prefix   = lv_prefix</item><item>                                                CHANGING  ct_rootname = lt_rootname ).   &quot;&lt;------ Elenco ROOTNAME da Change Number</item><item/><item>  &quot; Algoritmo in profondità</item><item>  TYPES: BEGIN OF ty_s_data_local.</item><item>  TYPES:   group TYPE i.</item><item>      INCLUDE TYPE ty_s_data.</item><item>  TYPES: END OF ty_s_data_local.</item><item>  TYPES: ty_t_data_local TYPE TABLE OF ty_s_data_local.</item><item/><item>  DATA: lt_data       TYPE ty_t_data,       &quot;tabella di appoggio in cui copio la gt_data</item><item>        lt_data_i     TYPE ty_t_data_local, &quot;tabella con tutti gli inserimenti</item><item>        lt_data_u     TYPE ty_t_data_local, &quot;tabella con tutte le modifiche (coppie I-D raggruppate per group)</item><item>        lt_data_d     TYPE ty_t_data_local, &quot;tabella delle cancellazioni</item><item>        ls_data_local TYPE ty_s_data_local,</item><item>        lv_group_i    TYPE i,</item><item>        lv_group_u    TYPE i,</item><item>        lv_group_d    TYPE i.</item><item/><item>  CLEAR: lt_data_i, lt_data_u, lt_data_d.</item><item>  lv_group_i = lv_group_u = lv_group_d = 1.</item><item>  lt_data[] = gt_data[].</item><item>  SORT lt_data BY rootname matnr idnrk datum uzeit vbkz.</item><item>  DELETE lt_data WHERE aennr(1) &lt;&gt; lv_prefix.</item><item>* Valorizzare le tabelle interne lt_data_*  ma solo la lt_data_i sarà a seguire utilizzata</item><item>  LOOP AT lt_data INTO ls_data WHERE aennr(1) = lv_prefix.</item><item>    DATA(lv_tabix) = sy-tabix.</item><item>    TRY.</item><item>*        DATA(ls_data_2) = gt_rootnames[ rootname = ls_data-rootname ].</item><item>        &quot; verifica se il nodo è foglia</item><item>        DATA(ls_data_2) = gt_data[ aennr = ls_data-aennr</item><item>                                   rootname = ls_data-rootname</item><item>                                   matnr = ls_data-idnrk ].</item><item>        DELETE lt_data.</item><item/><item>      CATCH cx_root.</item><item/><item>        SELECT SINGLE matnr INTO @DATA(lv_matnr)</item><item>               FROM marc</item><item>               WHERE werks = @zcl_pp_ectr=&gt;c_werks  &quot;6301</item><item>               AND   matnr = @ls_data-idnrk</item><item>               AND   disgr = @zcl_pp_ectr=&gt;c_disgr  &quot;ZMTO</item><item>               AND ( beskz = &apos;E&apos; OR ( beskz = &apos;F&apos; AND sobsl = &apos;30&apos; ) ).</item><item>        IF ( sy-subrc = 0 ).</item><item>          CASE ls_data-vbkz.</item><item>            WHEN &apos;D&apos;.</item><item>              READ TABLE lt_data INTO ls_data_2 WITH KEY rootname     = ls_data-rootname</item><item>                                                         matnr        = ls_data-matnr</item><item>                                                         idnrk        = ls_data-idnrk</item><item>                                                         relstartdate = ls_data-relstartdate</item><item>                                                         relenddate   = zcl_pp_ectr=&gt;c_infinite_date  &quot;31/12/2099 00:00:00</item><item>                                                         vbkz         = &apos;I&apos;.</item><item>              IF ( sy-subrc = 0 ).</item><item>                DATA(lv_tabix_2) = sy-tabix.</item><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_u.</item><item>                APPEND ls_data_local TO lt_data_u.   &quot;&lt;------</item><item/><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_u.</item><item>                APPEND ls_data_local TO lt_data_u.   &quot;&lt;------</item><item>                ADD 1 TO lv_group_u.</item><item/><item>                DELETE lt_data INDEX lv_tabix_2.</item><item>                IF ( lv_tabix &gt; lv_tabix_2 ).</item><item>                  DELETE lt_data INDEX lv_tabix_2.</item><item>                ELSE.</item><item>                  DELETE lt_data INDEX lv_tabix.</item><item>                ENDIF.</item><item>              ELSE.</item><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_d.</item><item>                APPEND ls_data_local TO lt_data_d.   &quot;&lt;------</item><item>                ADD 1 TO lv_group_d.</item><item/><item>                DELETE lt_data INDEX lv_tabix.</item><item>              ENDIF.</item><item>              CONTINUE.</item><item/><item>            WHEN &apos;I&apos;.</item><item>              READ TABLE lt_data INTO ls_data_2 WITH KEY rootname     = ls_data-rootname</item><item>                                                         matnr        = ls_data-matnr</item><item>                                                         idnrk        = ls_data-idnrk</item><item>                                                         relstartdate = ls_data-relstartdate</item><item>                                                         vbkz         = &apos;D&apos;.</item><item>              IF ( sy-subrc = 0 ).</item><item>                lv_tabix_2 = sy-tabix.</item><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_u.</item><item>                APPEND ls_data_local TO lt_data_u.   &quot;&lt;------</item><item/><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_u.</item><item>                APPEND ls_data_local TO lt_data_u.   &quot;&lt;------</item><item>                ADD 1 TO lv_group_u.</item><item/><item>                DELETE lt_data INDEX lv_tabix_2.</item><item>                IF ( lv_tabix &gt; lv_tabix_2 ).</item><item>                  DELETE lt_data INDEX lv_tabix_2.</item><item>                ELSE.</item><item>                  DELETE lt_data INDEX lv_tabix.</item><item>                ENDIF.</item><item>              ELSE.</item><item>                MOVE-CORRESPONDING ls_data TO ls_data_local.</item><item>                ls_data_local-group = lv_group_i.</item><item>                APPEND ls_data_local TO lt_data_i.   &quot;&lt;------</item><item>                ADD 1 TO lv_group_i.</item><item/><item>                DELETE lt_data INDEX lv_tabix.</item><item>              ENDIF.</item><item>              CONTINUE.</item><item/><item>          ENDCASE.</item><item>        ENDIF.</item><item>        DELETE lt_data INDEX lv_tabix.</item><item>        CONTINUE.</item><item>    ENDTRY.</item><item>  ENDLOOP.   &quot;LOOP AT lt_data INTO ls_data WHERE aennr(1) = lv_prefix.</item><item/><item>  DATA: lt_data_leaf TYPE ty_t_data.</item><item>  REFRESH: lt_data_leaf.</item><item>  LOOP AT gt_data INTO ls_data WHERE aennr(1) = lv_prefix.</item><item>    TRY.</item><item>        ls_data_local = lt_data_i[ rootname     = ls_data-rootname</item><item>                                   matnr        = ls_data-matnr</item><item>                                   idnrk        = ls_data-idnrk</item><item>                                   relstartdate = ls_data-relstartdate ].</item><item>*       CATCH cx_root.</item><item>        DATA(ls_bom) = zcl_pp_ectr=&gt;get_bom( iv_capid = &apos;PC01&apos;</item><item>                                             iv_datuv = sy-datum</item><item>                                             iv_matnr = ls_data-idnrk</item><item>                                             iv_ememg = 1</item><item>                                             iv_mehrs = abap_true</item><item>                                             iv_stlan = ls_data-stlan</item><item>                                             iv_stlal = ls_data-stlal</item><item>                                             iv_mto   = abap_true  ).</item><item>        LOOP AT ls_bom-t_stb INTO DATA(ls_stb).</item><item>*            READ TABLE gt_data INTO ls_data WITH KEY rootname = ls_pdm_nor_bom-rootname</item><item>          READ TABLE gt_data INTO ls_data WITH KEY rootname = ls_data-rootname</item><item>                                                   matnr    = ls_stb-baugr   &quot;Padre</item><item>                                                   idnrk    = ls_stb-idnrk.  &quot;Componente</item><item>          IF ( sy-subrc = 0 ).</item><item>*                &quot; Caso 1. Legame Padre-Componente è già sulla gt_data</item><item>*                ls_data = gt_data[ matnr = ls_stb-baugr idnrk = ls_stb-idnrk ].</item><item>*                DATA(lv_tabix) = sy-tabix.</item><item>*                ls_data-rootname = ls_pdm_nor_bom-rootname.</item><item>*                ls_data-posid = lt_rootname[ aennr = ls_data-aennr</item><item>*                                             rootname = ls_data-rootname ]-posid.</item><item>*                ls_data-dispo = lt_rootname[ aennr = ls_data-aennr</item><item>*                                             rootname = ls_data-rootname ]-dispo.</item><item>*                ls_data-to_save = abap_true.         &quot;Flag per indicare che il record sarà salvato in ZPP_MODBOM</item><item>*                MODIFY gt_data FROM ls_data INDEX lv_tabix TRANSPORTING rootname posid dispo to_save.</item><item>          ELSE.</item><item>            &quot; Caso 2. Legame Padre-Componente non presente sulla gt_data</item><item>            CLEAR: ls_data.</item><item>*                  ls_data = gt_data[ idnrk = ls_stb-baugr ].</item><item>            TRY.</item><item>                ls_data = gt_data[ idnrk = ls_stb-baugr ].</item><item>              CATCH cx_root.</item><item>                ls_data = lt_data_leaf[ idnrk = ls_stb-baugr ].</item><item>            ENDTRY.</item><item>            CLEAR: ls_data-relstartdate, ls_data-relenddate.</item><item>            MOVE-CORRESPONDING ls_stb TO ls_data.</item><item>            ls_data-mandt = sy-mandt.</item><item>*              ls_data-rootname = ls_pdm_nor_bom-rootname.</item><item>            ls_data-rootname = ls_data_local-rootname. &quot;ls_data-rootname.</item><item>            ls_data-posid = space.</item><item>            ls_data-dispo = space.</item><item>            ls_data-matnr = ls_stb-baugr.</item><item>            ls_data-idnrk = ls_stb-idnrk.</item><item>            ls_data-relqty = ls_stb-menge.</item><item>*              ls_data-posid = lt_rootname[ aennr = ls_data-aennr</item><item>*                                           rootname = ls_data-rootname ]-posid.</item><item>*              ls_data-dispo = lt_rootname[ aennr = ls_data-aennr</item><item>*                                           rootname = ls_data-rootname ]-dispo.</item><item>            &quot; Le date RELSTARTDATE e RELENDDATE devono essere recuperate dalla ZPP_PDM_NOR_BOM sull&apos;ultimo record</item><item>            &quot; a parità di PARENTNAME ( ls_data-matnr )  / CHILDNAME ( ls_data-idnrk ) / ROOTNAME ( ls_data-rootname )</item><item>            &quot; Quindi il MAX ( RELSTARTDATE )</item><item>            &quot; ...</item><item/><item>            &quot; Se nessun record è presente sulla ZPP_PDM_NOR_BOM allora lettura ZPP_MODBOM</item><item>            &quot; essendo un legame da BOM SCHELTRO avremo un solo record</item><item>            &quot; ...</item><item/><item>            zcl_pp_ectr=&gt;get_bom_dates( EXPORTING iv_rootname   = ls_data-rootname</item><item>                                                  iv_parentname = ls_data-matnr</item><item>                                                  iv_childname  = ls_data-idnrk</item><item>                                        CHANGING  cv_relstartdate = ls_data-relstartdate</item><item>                                                  cv_relenddate   = ls_data-relenddate</item><item>                                                  cv_datum        = ls_data-datum</item><item>                                                  cv_uzeit        = ls_data-uzeit ).</item><item/><item>            ls_data-vbkz = &apos;I&apos;.</item><item>            ls_data-to_save = abap_false.         &quot;Flag per indicare che il record non sarà salvato in ZPP_MODBOM</item><item>*            IF ( zcl_pp_ectr=&gt;contains( is_data = ls_data it_data = gt_data[] ) &lt;&gt; 0 ).</item><item>            IF ( NOT line_exists( gt_data[ table_line = ls_data ] ) ).</item><item>              APPEND ls_data TO lt_data_leaf.   &quot;&lt;------</item><item>            ENDIF.</item><item>          ENDIF.</item><item>        ENDLOOP.  &quot;LOOP AT ls_bom-t_stb INTO DATA(ls_stb).</item><item>      CATCH cx_root.</item><item/><item>    ENDTRY.</item><item>  ENDLOOP.</item><item>  APPEND LINES OF lt_data_leaf TO gt_data.   &quot;&lt;------</item><item/><item>  DATA: lv_rootname TYPE zpp_albero-rootname,</item><item>        lv_posid    TYPE prps-posid,</item><item>        lv_dispo    TYPE marc-dispo..</item><item>  CLEAR: lv_rootname, lv_posid, lv_dispo.</item><item/><item>  SORT gt_data BY rootname.</item><item/><item>* Estrazione della WBS e del Resp.MRP</item><item>  LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;)</item><item>    WHERE rootname IS NOT  INITIAL</item><item>      AND ( posid IS INITIAL OR dispo IS INITIAL ).</item><item>    IF ( lv_rootname &lt;&gt; &lt;ls_data&gt;-rootname ).</item><item>      CLEAR: lv_posid, lv_dispo.</item><item>      get_wbs_dispo( EXPORTING iv_rootname = &lt;ls_data&gt;-rootname</item><item>                      CHANGING  cv_posid = lv_posid</item><item>                                cv_dispo = lv_dispo ).</item><item>    ENDIF.</item><item>    &lt;ls_data&gt;-posid = lv_posid.</item><item>    &lt;ls_data&gt;-dispo = lv_dispo.</item><item>    lv_rootname = &lt;ls_data&gt;-rootname.</item><item>  ENDLOOP.   &quot;LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;).</item><item/><item>  SORT gt_data BY rootname matnr idnrk datum uzeit vbkz.</item><item/><item>  delete_duplicates( ).</item><item/><item>ENDMETHOD.</item></FIND_ROOTNAME_MEC><FIND_ROOTNAME_SCH><item>METHOD find_rootname_sch.</item><item>  TYPES: BEGIN OF ty_s_matnr,</item><item>           matnr TYPE matnr,</item><item>           stlan TYPE stlan,</item><item>           stlal TYPE stlal,</item><item>         END OF ty_s_matnr,</item><item>         ty_t_matnr TYPE TABLE OF ty_s_matnr.</item><item/><item>  DATA: lt_matnr TYPE ty_t_matnr,</item><item>        ls_matnr TYPE ty_s_matnr.</item><item/><item>  BREAK kosmedev.</item><item>  REFRESH: lt_matnr, gt_rootnames.</item><item>* Estrazione raggruppata dei ROOTNAME nella tabella interna lt_matnr</item><item>  LOOP AT gt_data INTO DATA(ls_data) WHERE ( matnr(1) = &apos;K&apos; OR matnr(1) = &apos;6&apos; ).   &quot;&lt;------</item><item>*   Non attivare i seguenti filtri perchè eventuali modifiche tecniche alla BOM 3 del ROOTNAME</item><item>*   non sarebbero processate correttamente</item><item>    &quot;AND sortf_new = zcl_pp_ectr=&gt;c_scheletro  &quot;SCHELETRO</item><item>    &quot;AND  aennr IS INITIAL.</item><item>*    CHECK ls_data-aennr(4) &lt;&gt; zcl_pp_ectr=&gt;c_elettrico.</item><item>    CLEAR: ls_matnr.</item><item>    MOVE-CORRESPONDING ls_data TO ls_matnr.</item><item>    COLLECT ls_matnr INTO lt_matnr.   &quot;&lt;------</item><item>  ENDLOOP.</item><item/><item>  LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;).</item><item>    &lt;ls_data&gt;-to_save = abap_true.  &quot;Flag per indicare che il record sarà salvato in ZPP_MODBO</item><item>  ENDLOOP.</item><item/><item>  SORT lt_matnr BY matnr.</item><item/><item>* Elaborazione dei ROOTNAME</item><item>  LOOP AT lt_matnr INTO ls_matnr.</item><item>*   Per ogni ROOTNAME identificato esplosione della BOM Multilivello</item><item>    DATA(ls_bom) = zcl_pp_ectr=&gt;get_bom( iv_capid = &apos;PC01&apos;</item><item>                                         iv_datuv = sy-datum</item><item>                                         iv_matnr = ls_matnr-matnr</item><item>                                         iv_ememg = 1</item><item>                                         iv_mehrs = abap_true</item><item>                                         iv_stlan = ls_matnr-stlan</item><item>                                         iv_stlal = ls_matnr-stlal</item><item>                                         iv_mto   = abap_true  ).</item><item/><item>*   LOOP sui componenti della BOM Multilivello discriminando se il legame Padre-Componente</item><item>*   è già sulla gt_data oppure è nuovo. In presenza di un nuovo legame è necessario identificare RELSTARTDATE e RELENDDATE</item><item>    LOOP AT ls_bom-t_stb INTO DATA(ls_stb).</item><item>      READ TABLE gt_data INTO ls_data WITH KEY rootname  = space</item><item>                                               matnr     = ls_stb-baugr   &quot;Padre</item><item>                                               idnrk     = ls_stb-idnrk.  &quot;Componente</item><item>*       Non attivare i seguenti filtri, la ricerca deve essere sul legame Padre-Componente</item><item>*                                              aennr     = space.</item><item>*                                              sortf_new = zcl_pp_ectr=&gt;c_scheletro.  &quot;SCHELETRO</item><item>      IF ( sy-subrc = 0 ).</item><item>*       Caso 1. Legame Padre-Componente è già sulla gt_data</item><item>        DATA(lv_tabix) = sy-tabix.</item><item>        ls_data-rootname = ls_matnr-matnr.</item><item>        IF ls_data-aennr IS INITIAL.</item><item>*         Se il numero di modifica è valorizzato sarà elaborato negl&apos;altri metodi</item><item>          MODIFY gt_data FROM ls_data INDEX lv_tabix TRANSPORTING rootname to_save.</item><item>        ENDIF.</item><item>        DO 1000 TIMES .</item><item>*         Verificare se abbiamo altri legami identici (es. in caso di modifica)</item><item>          READ TABLE gt_data INTO ls_data WITH KEY rootname  = space</item><item>                                                   matnr     = ls_stb-baugr   &quot;Padre</item><item>                                                   idnrk     = ls_stb-idnrk.  &quot;Componente</item><item/><item>          IF ( sy-subrc = 0 ).</item><item>            lv_tabix = sy-tabix.</item><item>            ls_data-rootname = ls_matnr-matnr.</item><item>            IF ls_data-aennr IS INITIAL.</item><item>              MODIFY gt_data FROM ls_data INDEX lv_tabix TRANSPORTING rootname to_save.</item><item>            ENDIF.</item><item>          ELSE.</item><item>            EXIT.   &quot;------&gt; USCITA DO</item><item>          ENDIF.</item><item>        ENDDO.</item><item>      ELSE.</item><item>*       Caso 2. Legame Padre-Componente non presente sulla gt_data</item><item>        CLEAR: ls_data.</item><item>*       ls_data = gt_data[ idnrk = ls_stb-baugr ].</item><item>*       ls_data = gt_data[ matnr = ls_stb-baugr ].</item><item>        ls_data = gt_data[ matnr = ls_matnr-matnr ].    &quot;Selezione di un record qualsiasi tra quelli del ROOTNAME</item><item>        CLEAR: ls_data-relstartdate, ls_data-relenddate, ls_data-sortf_new.</item><item>        MOVE-CORRESPONDING ls_stb TO ls_data.</item><item>        ls_data-mandt = sy-mandt.</item><item>        ls_data-rootname = ls_matnr-matnr.  &quot;ROOTNAME</item><item>        CLEAR: ls_data-posid, ls_data-dispo.</item><item>        ls_data-matnr = ls_stb-baugr.       &quot;PARENTNAME</item><item>        ls_data-idnrk = ls_stb-idnrk.       &quot;CHILDNAME</item><item>        ls_data-relqty = ls_stb-menge.      &quot;RELQTY</item><item>        ls_data-sortf_new = ls_stb-sortf.</item><item>*         Le date RELSTARTDATE e RELENDDATE devono essere recuperate dalla ZPP_PDM_NOR_BOM sull&apos;ultimo record</item><item>*         a parità di PARENTNAME ( ls_data-matnr )  / CHILDNAME ( ls_data-idnrk ) / ROOTNAME ( ls_data-rootname )</item><item>*         Quindi il MAX ( RELSTARTDATE )</item><item>*         ...</item><item/><item>*         Se nessun record è presente sulla ZPP_PDM_NOR_BOM allora lettura ZPP_MODBOM</item><item>*         essendo un legame da BOM SCHELTRO avremo un solo record</item><item>*         ...</item><item/><item>*          ls_data-relstartdate = ls_stb-datuv+6(2) &amp;&amp; &apos;/&apos; &amp;&amp; ls_stb-datuv+4(2) &amp;&amp; &apos;/&apos; &amp;&amp; ls_stb-datuv(4) &amp;&amp;</item><item>        zcl_pp_ectr=&gt;get_bom_dates( EXPORTING iv_rootname   = ls_data-rootname</item><item>                                              iv_parentname = ls_data-matnr</item><item>                                              iv_childname  = ls_data-idnrk</item><item>                                    CHANGING  cv_relstartdate = ls_data-relstartdate</item><item>                                              cv_relenddate   = ls_data-relenddate</item><item>                                              cv_datum        = ls_data-datum</item><item>                                              cv_uzeit        = ls_data-uzeit ).</item><item>        CLEAR: ls_data-posid, ls_data-dispo.</item><item>        ls_data-vbkz = &apos;I&apos;.</item><item>        ls_data-to_save = abap_false.         &quot;Flag per indicare che il record non sarà salvato in ZPP_MODBOM</item><item>*        IF ( zcl_pp_ectr=&gt;contains( is_data = ls_data it_data = gt_data[] ) &lt;&gt; 0 ).</item><item>        IF ( NOT line_exists( gt_data[ table_line = ls_data ] ) ).</item><item>          APPEND ls_data TO gt_data.</item><item>        ENDIF.</item><item>      ENDIF.</item><item>      DATA: ls_rootnames TYPE ty_s_rootnames.</item><item>      MOVE-CORRESPONDING ls_data TO ls_rootnames.</item><item>      COLLECT ls_rootnames INTO gt_rootnames.</item><item>    ENDLOOP.   &quot;LOOP AT ls_bom-t_stb INTO DATA(ls_stb).</item><item>  ENDLOOP.   &quot;LOOP AT lt_matnr INTO ls_matnr.</item><item/><item>  SORT gt_data BY rootname datum uzeit.</item><item/><item>  DATA: lv_rootname TYPE zpp_albero-rootname,</item><item>        lv_posid    TYPE prps-posid,</item><item>        lv_dispo    TYPE marc-dispo.</item><item>  CLEAR: lv_rootname, lv_posid, lv_dispo.</item><item/><item>  SORT gt_data BY rootname.</item><item/><item>* Estrazione della WBS e del Resp.MRP</item><item>  LOOP AT gt_data ASSIGNING &lt;ls_data&gt;</item><item>    WHERE rootname IS NOT INITIAL.</item><item>    IF ( lv_rootname &lt;&gt; &lt;ls_data&gt;-rootname ).</item><item>      CLEAR: lv_posid, lv_dispo.</item><item>      get_wbs_dispo( EXPORTING iv_rootname = &lt;ls_data&gt;-rootname</item><item>                      CHANGING  cv_posid = lv_posid</item><item>                                cv_dispo = lv_dispo ).</item><item>    ENDIF.</item><item>    &lt;ls_data&gt;-posid = lv_posid.</item><item>    &lt;ls_data&gt;-dispo = lv_dispo.</item><item>    lv_rootname = &lt;ls_data&gt;-rootname.</item><item>  ENDLOOP.   &quot;LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;).</item><item/><item>  &quot;SORT gt_data BY datum uzeit matnr idnrk vbkz.</item><item>  SORT gt_data BY rootname matnr idnrk datum uzeit vbkz.</item><item/><item>ENDMETHOD.</item></FIND_ROOTNAME_SCH><DELETE_DUPLICATES><item>  METHOD delete_duplicates.</item><item>    LOOP AT gt_data INTO DATA(ls_data) WHERE to_save = abap_true.</item><item>      LOOP AT gt_data INTO DATA(ls_data_2) WHERE rootname     = ls_data-rootname</item><item>                                           AND   matnr        = ls_data-matnr</item><item>                                           AND   idnrk        = ls_data-idnrk</item><item>                                           AND   relstartdate = ls_data-relstartdate</item><item>                                           AND   relenddate   = ls_data-relenddate</item><item>                                           AND   to_save      = abap_false.</item><item>        DELETE gt_data.</item><item>      ENDLOOP.</item><item>    ENDLOOP.</item><item>  ENDMETHOD.</item></DELETE_DUPLICATES><GET_ACTIVE_COMPONENTS><item> METHOD get_active_components.</item><item/><item>   REFRESH: rt_pdm_nor_bom.   &quot;Tabella like ZPP_PDM_NOR_BOM con i nuovi record validi. Al momento non utilizzata</item><item>   &quot; estrazione componenti attivi per i rootname trovati sopra (tabella LT_ROOTNAME)</item><item>   DATA: lt_pdm_nor_bom_2 TYPE TABLE OF zpp_pdm_nor_bom,</item><item>         lt_pdm_nor_bom_r TYPE TABLE OF zpp_pdm_nor_bom,</item><item>         lv_pdm_nor_bom_r TYPE zpp_pdm_nor_bom.</item><item/><item>**  Determina il primo ROOTNAME valido tra quelli della classificazione del change number</item><item>**  Può succedere che non si determini alcun ROOTNAME se quelli della classificazione sono fuori ambito</item><item>*   LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;) WHERE aennr(1) = iv_prefix.</item><item>**                                                    AND   valid    = abap_true.</item><item>*     LOOP AT ct_rootname INTO DATA(ls_rootname).</item><item>*       zcl_pp_ectr=&gt;get_active_nodes( EXPORTING iv_rootname   = ls_rootname-rootname</item><item>**                                                iv_parentname = &lt;ls_data&gt;-matnr</item><item>*                                                iv_childname  = &lt;ls_data&gt;-matnr</item><item>*                                      CHANGING ct_nor_bom = lt_pdm_nor_bom_r ).</item><item>*       TRY.</item><item>*           &lt;ls_data&gt;-rootname = lt_pdm_nor_bom_r[ 1 ]-rootname.</item><item>*           EXIT.</item><item>*         CATCH cx_root.</item><item>*       ENDTRY.</item><item>*     ENDLOOP.</item><item>*   ENDLOOP.</item><item/><item>   BREAK kosmedev.</item><item>   DATA: ls_rootname TYPE ty_s_rootname.</item><item>*  Il legame PARENTNAME-CHILDNAME deve trovare un collegamento nell&apos;albero BOM del ROOTNAME</item><item>*  1. Ricercare tale collegamento nella tabella ZPP_PDM_NOR_BOM</item><item>   LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;) WHERE ( aennr(1) = iv_prefix OR</item><item>                                                             aennr(4) = iv_prefix )</item><item>                                                      AND   rootname IS INITIAL.</item><item/><item>     IF ( &lt;ls_data&gt;-matnr(1) = &apos;K&apos; OR &lt;ls_data&gt;-matnr(1) = &apos;6&apos; ).</item><item>       &lt;ls_data&gt;-rootname = &lt;ls_data&gt;-matnr.</item><item>     ELSE.</item><item>*      Nella tabella lt_pdm_nor_bom_r abbiamo l&apos;elenco dei ROOTNAME attivi in cui il Materiale è presente</item><item>*      determinati leggendo la tabella ZPP_PDM_NOR_BOM</item><item>       zcl_pp_ectr=&gt;get_active_nodes( EXPORTING&quot;iv_rootname = ls_rootname-rootname</item><item>*                                             iv_parentname = &lt;ls_data&gt;-matnr</item><item>                                                iv_childname  = &lt;ls_data&gt;-matnr</item><item>                                      CHANGING ct_nor_bom = lt_pdm_nor_bom_r ).</item><item>       LOOP AT lt_pdm_nor_bom_r INTO lv_pdm_nor_bom_r.</item><item>         IF sy-tabix = 1.</item><item>           &lt;ls_data&gt;-rootname = lv_pdm_nor_bom_r-rootname.</item><item>         ELSE.</item><item>           DATA(ls_data_1) = &lt;ls_data&gt;.</item><item>           ls_data_1-rootname = lv_pdm_nor_bom_r-rootname.</item><item>           ls_data_1-to_save = abap_false.</item><item>           CLEAR: ls_data_1-posid, ls_data_1-dispo.</item><item>*         IF ( zcl_pp_ectr=&gt;contains( is_data = ls_data_1 it_data = gt_data[] ) &lt;&gt; 0 ).</item><item>           IF ( NOT line_exists( gt_data[ table_line = ls_data_1 ] ) ).</item><item>             APPEND ls_data_1 TO gt_data.</item><item>           ENDIF.</item><item>         ENDIF.</item><item>       ENDLOOP.</item><item>*     TRY.</item><item>*         &lt;ls_data&gt;-rootname = lt_pdm_nor_bom_r[ 1 ]-rootname.</item><item>**         EXIT.</item><item>*       CATCH cx_root.</item><item>*     ENDTRY.</item><item>     ENDIF.</item><item/><item>   ENDLOOP.   &quot;LOOP AT gt_data ASSIGNING FIELD-SYMBOL(&lt;ls_data&gt;) WHERE ( aennr(1) = iv_prefix OR</item><item/><item>   DATA: l_trova TYPE c.</item><item>*  Il legame PARENTNAME-CHILDNAME deve trovare un collegamento nell&apos;albero BOM del ROOTNAME</item><item>*  2. Ricercare tale collegamento nella tabella interna gt_data.</item><item>   DO 100 TIMES.</item><item>     CLEAR: l_trova.</item><item>     LOOP AT gt_data ASSIGNING &lt;ls_data&gt; WHERE ( aennr(1) = iv_prefix OR</item><item>                                                 aennr(4) = iv_prefix )</item><item>                                           AND rootname IS INITIAL.</item><item>       LOOP AT gt_data INTO DATA(ls_data_3) WHERE ( aennr(1) = iv_prefix OR</item><item>                                                    aennr(4) = iv_prefix )</item><item>                                             AND   idnrk = &lt;ls_data&gt;-matnr</item><item>                                             AND   rootname IS NOT INITIAL.</item><item>          &lt;ls_data&gt;-rootname = ls_data_3-rootname.</item><item>          l_trova = &apos;X&apos;.   &quot;&lt;------</item><item>          EXIT.</item><item>       ENDLOOP.</item><item>     ENDLOOP.</item><item>     IF l_trova IS INITIAL.</item><item>       EXIT.   &quot;------&gt; USCITA DO</item><item>     ENDIF.</item><item>   ENDDO.   &quot;DO 100 TIMES.</item><item/><item>   DATA: lv_sortf TYPE sortp.</item><item>   DATA: lv_prefix    TYPE string.</item><item/><item>   lv_prefix = zcl_pp_ectr=&gt;c_elettrico.  &quot;&apos;BOM-&apos;.</item><item/><item>*  Gestione ROOTNAME alternativi ricavati dal SORTF del CAD Elettrico</item><item>   LOOP AT gt_data ASSIGNING &lt;ls_data&gt; WHERE aennr(4) = lv_prefix</item><item>                                         AND rootname IS NOT INITIAL.</item><item/><item>     IF ( NOT &lt;ls_data&gt;-sortf_new IS INITIAL ).</item><item>       lv_sortf = &lt;ls_data&gt;-sortf_new+1(9).</item><item>     ELSEIF ( NOT &lt;ls_data&gt;-sortf_old IS INITIAL ).</item><item>       lv_sortf = &lt;ls_data&gt;-sortf_old+1(9).</item><item>     ENDIF.</item><item>     CONDENSE: lv_sortf.</item><item>     IF &lt;ls_data&gt;-rootname &lt;&gt; lv_sortf.</item><item>       DATA(ls_data_2) = &lt;ls_data&gt;.</item><item>       ls_data_2-rootname = lv_sortf.</item><item>       ls_data_2-to_save = abap_false.</item><item>       CLEAR: ls_data_2-posid, ls_data_2-dispo.</item><item>*       IF ( zcl_pp_ectr=&gt;contains( is_data = ls_data_2 it_data = gt_data[] ) &lt;&gt; 0 ).</item><item>       IF ( NOT line_exists( gt_data[ table_line = ls_data_2 ] ) ).</item><item>         APPEND ls_data_2 TO gt_data.</item><item>       ENDIF.</item><item>     ENDIF.</item><item>   ENDLOOP.</item><item/><item>   RETURN.   &quot;&lt;------</item><item/><item>*   DATA: lt_rootnames TYPE ty_t_rootnames,</item><item>*         ls_rootnames TYPE ty_s_rootnames.</item><item>*   REFRESH: lt_rootnames.</item><item>*</item><item>*   LOOP AT gt_data ASSIGNING &lt;ls_data&gt; WHERE ( aennr(1) = iv_prefix OR</item><item>*                                               aennr(4) = iv_prefix ).</item><item>*     LOOP AT ct_rootname INTO DATA(ls_root) WHERE aennr = &lt;ls_data&gt;-aennr.</item><item>*       IF ( NOT &lt;ls_data&gt;-rootname IS INITIAL ).</item><item>*         &lt;ls_data&gt;-rootname = ls_root-rootname.   &quot;</item><item>*         &lt;ls_data&gt;-posid    = ls_root-posid.      &quot;WBS</item><item>*         &lt;ls_data&gt;-dispo    = ls_root-dispo.</item><item>*       ENDIF.</item><item>*       LOOP AT rt_pdm_nor_bom INTO DATA(ls_pdm_nor_bom) WHERE rootname &lt;&gt; &lt;ls_data&gt;-rootname</item><item>*                                                        AND   childname = &lt;ls_data&gt;-matnr.</item><item>*         EXIT.</item><item>*       ENDLOOP.</item><item>*       CHECK sy-subrc &lt;&gt; 0.</item><item>**        Estrazione dei potenziali materiali presenti in altri ROOTNAME</item><item>*       SELECT mandt, parentname, childname, rootname</item><item>*              INTO TABLE @lt_pdm_nor_bom_2</item><item>*              FROM zpp_pdm_nor_bom</item><item>*              WHERE rootname   &lt;&gt; @&lt;ls_data&gt;-rootname   &quot;Ricerca di un&apos;altro ROOTNAME</item><item>*              AND   childname  =  @&lt;ls_data&gt;-matnr</item><item>*              AND   relenddate =  @zcl_pp_ectr=&gt;c_infinite_date</item><item>*              GROUP BY mandt, rootname, parentname, childname.</item><item>***        Gestione di change number con in classificazione più ROOTNAME</item><item>**       LOOP AT lt_pdm_nor_bom_2 INTO ls_pdm_nor_bom.</item><item>**         DATA(xtabix) = sy-tabix.</item><item>**         READ TABLE ct_rootname TRANSPORTING NO FIELDS WITH KEY rootname = ls_pdm_nor_bom-rootname.</item><item>**         IF sy-subrc = 0.</item><item>**           DELETE lt_pdm_nor_bom_2 INDEX xtabix.</item><item>**         ENDIF.</item><item>**       ENDLOOP.</item><item>**       LOOP AT lt_rootnames INTO ls_rootnames.</item><item>**         DELETE lt_pdm_nor_bom_2 WHERE rootname = ls_rootnames-rootname.</item><item>**       ENDLOOP.</item><item>*       LOOP AT lt_pdm_nor_bom_2 INTO ls_pdm_nor_bom.</item><item>*         zcl_pp_ectr=&gt;get_active_nodes( EXPORTING iv_rootname   = ls_pdm_nor_bom-rootname</item><item>*                                                  iv_parentname = ls_pdm_nor_bom-parentname</item><item>*                                                  iv_childname  = ls_pdm_nor_bom-childname</item><item>*                                        CHANGING ct_nor_bom = lt_pdm_nor_bom_r ).</item><item>*         APPEND LINES OF lt_pdm_nor_bom_r TO rt_pdm_nor_bom.   &quot;&lt;------</item><item>*       ENDLOOP.</item><item>*       ls_rootnames-rootname = ls_rootname-rootname.</item><item>*       COLLECT ls_rootnames INTO lt_rootnames.   &quot;&lt;------</item><item>*     ENDLOOP.   &quot;LOOP AT ct_rootname INTO DATA(ls_root) WHERE aennr = &lt;ls_data&gt;-aennr.</item><item>*   ENDLOOP.   &quot;LOOP AT gt_data ASSIGNING &lt;ls_data&gt; WHERE aennr(1) = iv_prefix.</item><item>*</item><item>*   BREAK kosmedev.</item><item>*   DATA: lt_data_tmp TYPE ty_t_data.</item><item>*   REFRESH: lt_data_tmp.</item><item>*   DELETE ADJACENT DUPLICATES FROM rt_pdm_nor_bom COMPARING rootname parentname childname.</item><item>*   LOOP AT rt_pdm_nor_bom INTO ls_pdm_nor_bom.</item><item>*     LOOP AT gt_data INTO DATA(ls_data) &quot;WHERE rootname &lt;&gt; ls_pdm_nor_bom-rootname</item><item>*                                         WHERE   matnr    = ls_pdm_nor_bom-childname.</item><item>*       READ TABLE lt_data_tmp WITH KEY rootname = ls_pdm_nor_bom-rootname</item><item>*                                       matnr    = ls_pdm_nor_bom-parentname</item><item>*                                       idnrk    = ls_pdm_nor_bom-childname</item><item>*                                       relstartdate = ls_data-relstartdate</item><item>*                                       relenddate   = ls_data-relenddate</item><item>*                                       TRANSPORTING NO FIELDS.</item><item>*       IF ( sy-subrc &lt;&gt; 0 ).</item><item>*         ls_data-rootname = ls_pdm_nor_bom-rootname.</item><item>*         ls_data-to_save = abap_false.</item><item>*         APPEND ls_data TO lt_data_tmp.</item><item>*       ENDIF.</item><item>**      ls_rootname-aennr ls_data-aennr.</item><item>**       DATA: ls_rootname TYPE ty_s_rootname.</item><item>*       MOVE-CORRESPONDING ls_data TO ls_rootname.</item><item>*       COLLECT ls_rootname INTO ct_rootname.</item><item>**       DATA: ls_rootnames TYPE ty_s_rootnames.</item><item>*       CLEAR: ls_rootnames.</item><item>*       MOVE-CORRESPONDING ls_data TO ls_rootnames.</item><item>*       COLLECT ls_rootnames INTO gt_rootnames.</item><item>*     ENDLOOP.</item><item>*   ENDLOOP.</item><item>*   APPEND LINES OF lt_data_tmp TO gt_data.   &quot;&lt;------</item><item>*</item><item>*   delete_duplicates( ).</item><item/><item> ENDMETHOD.</item></GET_ACTIVE_COMPONENTS><GET_WBS_DISPO><item>METHOD get_wbs_dispo.</item><item/><item>  DATA: lv_wbsroot TYPE zps_wbs_aperte-zwbsroot.</item><item>  DATA: ls_wbs_aperte TYPE zps_wbs_aperte.</item><item>  lv_wbsroot = &apos;%&amp;%&apos; &amp;&amp; iv_rootname.</item><item>  SELECT SINGLE * INTO CORRESPONDING FIELDS OF ls_wbs_aperte</item><item>    FROM zps_wbs_aperte</item><item>    WHERE zwbsroot LIKE lv_wbsroot.</item><item>  IF ( sy-subrc = 0 ).</item><item>    DATA: lt_split TYPE TABLE OF string.</item><item>    REFRESH lt_split.</item><item>    SPLIT ls_wbs_aperte-zwbsroot AT &apos; &amp; &apos; INTO TABLE lt_split.</item><item>    TRY.</item><item>        cv_posid = lt_split[ 1 ].</item><item>      CATCH cx_root.</item><item>    ENDTRY.</item><item>  ELSE.</item><item>*   E&apos; arrivata una BOM scheletro su di un ROOTNAME senza WBS Aperta</item><item>*   Errore al momento non gestito ...</item><item>  ENDIF.</item><item>  SELECT SINGLE dispo INTO cv_dispo</item><item>    FROM marc</item><item>    WHERE matnr = iv_rootname</item><item>      AND werks = zcl_pp_ectr=&gt;c_werks.   &quot;6301   &quot;&lt;------</item><item/><item>ENDMETHOD.</item></GET_WBS_DISPO><DELETE_USELESS_NODES><item>  METHOD delete_useless_nodes.</item><item>    LOOP AT gt_data INTO DATA(ls_data).</item><item>      DATA(lv_tabix) = sy-tabix.</item><item>      SELECT SINGLE rootname INTO @DATA(lv_rootname)</item><item>             FROM zpp_pdm_nor_bom</item><item>             WHERE parentname = @ls_data-matnr</item><item>             AND   childname  = @ls_data-idnrk</item><item>             AND   rootname   = @ls_data-rootname</item><item>             AND   relstartdate = @ls_data-relstartdate</item><item>             AND   relenddate = @ls_data-relenddate</item><item>             AND   elaborato = @abap_true.</item><item>      IF ( sy-subrc = 0 ).</item><item>        DELETE gt_data INDEX lv_tabix.</item><item>*        CONTINUE.</item><item>      ENDIF.</item><item>    ENDLOOP.</item><item>  ENDMETHOD.</item></DELETE_USELESS_NODES></METHOD_SOURCE></CLASS_ROOT>